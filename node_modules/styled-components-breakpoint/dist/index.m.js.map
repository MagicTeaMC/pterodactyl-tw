{"version":3,"file":"index.m.js","sources":["../src/defaults.ts","../src/convertPxToEm.ts","../src/createBreakpoint.ts","../src/breakpoint.ts","../src/createMap.ts","../src/map.ts"],"sourcesContent":["import {BreakpointMap, DefaultBreakpointName} from './types';\n\nexport const defaults: BreakpointMap<DefaultBreakpointName> = {\n  // targeting all devices\n  mobile: 0,\n\n  // targeting devices that are LARGER than the iPhone 6 Plus (which is 736px in landscape mode)\n  tablet: 737,\n\n  // targeting devices that are LARGER than the 11\" iPad Pro (which is 1194px in landscape mode)\n  desktop: 1195,\n};\n","// @media is always calculated off 16px regardless of whether the root font size is the default or not\nexport const convertPxToEm = (pixels: number): number => pixels / 16;\n","import {css} from 'styled-components';\nimport {\n  BreakpointMap,\n  BreakpointNameConstraint,\n  BreakpointFunction,\n} from './types';\nimport {convertPxToEm} from './convertPxToEm';\n\nconst getBreakpointSize = <B extends BreakpointNameConstraint>(\n  breakpoints: BreakpointMap<B>,\n  breakpoint: B,\n): number => {\n  if (!(breakpoint in breakpoints)) {\n    console.error(\n      `styled-components-breakpoint: Breakpoint \"${breakpoint}\" was not found.`,\n    );\n    return 0;\n  }\n  return breakpoints[breakpoint];\n};\n\nexport const createBreakpoint = <B extends BreakpointNameConstraint>(\n  breakpoints: BreakpointMap<B>,\n): BreakpointFunction<B> => (breakpointA, breakpointB) => {\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  return (strings: any, ...interpolations: any[]) => {\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n    if (breakpointA && breakpointB) {\n      const pixelsA = getBreakpointSize(breakpoints, breakpointA);\n      const pixelsB = getBreakpointSize(breakpoints, breakpointB);\n      return css`\n        @media screen and (min-width: ${convertPxToEm(\n            pixelsA,\n          )}em) and (max-width: ${convertPxToEm(pixelsB - 1)}em) {\n          ${css(strings, ...interpolations)}\n        }\n      `;\n    } else {\n      const pixelsA = getBreakpointSize(breakpoints, breakpointA);\n      if (pixelsA === 0) {\n        return css(strings, ...interpolations);\n      } else {\n        return css`\n          @media screen and (min-width: ${convertPxToEm(pixelsA)}em) {\n            ${css(strings, ...interpolations)}\n          }\n        `;\n      }\n    }\n  };\n};\n","import {StyledProps, css} from 'styled-components';\nimport {ThemedBreakpointName, BreakpointMap} from './types';\nimport {defaults} from './defaults';\nimport {createBreakpoint} from './createBreakpoint';\n\ntype CSSFunction = (\n  ...params: Parameters<typeof css>\n) => <P extends object>({theme}: StyledProps<P>) => ReturnType<typeof css>;\n\ntype ThemedBreakpointMap = BreakpointMap<ThemedBreakpointName>;\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n// casting because we can't really do anything better when the theme is defined but no theme values are defined\nconst getBreakpointsFromTheme = <P extends object>({\n  theme,\n}: StyledProps<P>): ThemedBreakpointMap =>\n  theme && theme.breakpoints ? theme.breakpoints : (defaults as any);\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nexport const breakpoint = (\n  breakpointA: ThemedBreakpointName,\n  breakpointB?: ThemedBreakpointName,\n): CSSFunction => {\n  /* eslint-disable @typescript-eslint/no-explicit-any */\n  return (strings: any, ...interpolations: any[]) => {\n    /* eslint-enable @typescript-eslint/no-explicit-any */\n    return <P extends object>(props: StyledProps<P>) => {\n      return createBreakpoint<ThemedBreakpointName>(\n        getBreakpointsFromTheme(props),\n      )(breakpointA, breakpointB)(strings, interpolations);\n    };\n  };\n};\n","import {\n  BreakpointMap,\n  ValueOrValueMap,\n  BreakpointNameConstraint,\n  ValueConstraint,\n  ValueToStyleFunction,\n  ScaleConstraint,\n  MapFunction,\n} from './types';\nimport {createBreakpoint} from './createBreakpoint';\nimport {css, CSSObject, StyledProps, DefaultTheme} from 'styled-components';\n\n// ensure the values are keyed in breakpoint order, otherwise specificity issues may occur\nconst checkValuesOrdering = <\n  B extends BreakpointNameConstraint,\n  V extends ValueConstraint\n>(\n  breakpoints: BreakpointMap<B>,\n  values: ValueOrValueMap<B, V>,\n): void => {\n  const breakpointKeys = Object.keys(breakpoints);\n  let previousIndex = -1;\n  Object.keys(values).some(k => {\n    const index = breakpointKeys.indexOf(k);\n    if (index !== -1 && index <= previousIndex) {\n      console.warn(\n        `styled-components-breakpoint: Values for ${JSON.stringify(\n          values,\n        )} are not keyed in order (${breakpointKeys\n          .map(n => `\"${n}\"`)\n          .join(', ')}) and may result in specificity issues.`,\n      );\n      return true;\n    } else {\n      previousIndex = index;\n      return false;\n    }\n  });\n};\n\nfunction map<\n  B extends BreakpointNameConstraint,\n  V extends ValueConstraint,\n  S extends ScaleConstraint\n>(\n  breakpoints: BreakpointMap<B>,\n  valueOrValues: ValueOrValueMap<B, V>,\n  mapValueToStyle: ValueToStyleFunction<V, S>,\n  scale?: S,\n): string | ReturnType<typeof css> {\n  const fn = createBreakpoint<B>(breakpoints);\n\n  if (typeof valueOrValues !== 'object') {\n    const style = mapValueToStyle(valueOrValues);\n    // @see https://github.com/microsoft/TypeScript/issues/17002\n    return typeof style === 'string' || Array.isArray(style)\n      ? style\n      : css(style as CSSObject);\n  }\n\n  // check the ordering of breakpoints\n  if (process.env.NODE_ENV !== 'production') {\n    checkValuesOrdering(breakpoints, valueOrValues);\n  }\n\n  // map the value at each breakpoint to styles\n  const keys = Object.keys(valueOrValues) as B[];\n  return keys.map((key: B) => {\n    const tag = fn(key);\n    // FIXME: not sure why the type isn't correctly inferred here\n    const val: V | undefined = valueOrValues[key];\n    if (val === undefined) return '';\n    const style = mapValueToStyle(val, scale);\n    if (typeof style === 'string' || Array.isArray(style)) {\n      /* eslint-disable @typescript-eslint/ban-ts-ignore */\n      // @ts-ignore - ignore inability to create a real TemplateStringsArray\n      return tag([], style);\n      /* eslint-enable @typescript-eslint/ban-ts-ignore */\n    } else {\n      // @see https://github.com/microsoft/TypeScript/issues/17002\n      return tag(style as CSSObject);\n    }\n  });\n}\n\n/* eslint-disable @typescript-eslint/explicit-function-return-type */\nexport const createMap = <B extends BreakpointNameConstraint>(\n  breakpoints: BreakpointMap<B> | ((theme: DefaultTheme) => BreakpointMap<B>),\n): MapFunction<B> => {\n  return <V extends ValueConstraint, S extends ScaleConstraint>(\n    valueOrValues: ValueOrValueMap<B, V>,\n    mapValueToStyle: ValueToStyleFunction<V, S>,\n    scale?: S | ((theme: DefaultTheme) => S),\n  ) => {\n    if (typeof breakpoints !== 'object' || typeof scale !== 'object') {\n      return <P>(props: StyledProps<P>) => {\n        const b =\n          typeof breakpoints !== 'object'\n            ? breakpoints(props.theme)\n            : breakpoints;\n        const s =\n          scale !== undefined && typeof scale !== 'object'\n            ? scale(props.theme)\n            : scale;\n        return map(b, valueOrValues, mapValueToStyle, s);\n      };\n    } else {\n      return map(breakpoints, valueOrValues, mapValueToStyle, scale);\n    }\n  };\n};\n/* eslint-enable @typescript-eslint/explicit-function-return-type */\n","import 'styled-components';\nimport {defaults} from './defaults';\nimport {createMap} from './createMap';\nimport {ThemedBreakpointName} from './types';\n\nexport const map = createMap<ThemedBreakpointName>(\n  theme => (theme as any).breakpoints || defaults,\n);\n"],"names":["defaults","mobile","tablet","desktop","convertPxToEm","pixels","getBreakpointSize","breakpoints","breakpoint","console","error","createBreakpoint","breakpointA","breakpointB","strings","pixelsA","pixelsB","css","interpolations","props","theme","checkValuesOrdering","values","breakpointKeys","Object","keys","previousIndex","some","k","index","indexOf","warn","JSON","stringify","map","n","join","valueOrValues","mapValueToStyle","scale","fn","style","Array","isArray","process","env","NODE_ENV","key","tag","val","undefined","createMap","b","s"],"mappings":"4CAEaA,EAAiD,CAE5DC,OAAQ,EAGRC,OAAQ,IAGRC,QAAS,MCTEC,WAAiBC,UAA2BA,EAAS,mPCO5DC,WACJC,EACAC,UAEMA,KAAcD,EAMbA,EAAYC,IALjBC,QAAQC,mDACuCF,sBAExC,IAKEG,WACXJ,mBAC2BK,EAAaC,mBAEhCC,oEAEFF,GAAeC,EAAa,KACxBE,EAAUT,EAAkBC,EAAaK,GACzCI,EAAUV,EAAkBC,EAAaM,UACxCI,IAC2Bb,EAC5BW,GACsBX,EAAcY,EAAU,GAC9CC,gBAAIH,UAAYI,SAIhBH,EAAUT,EAAkBC,EAAaK,UAC/B,IAAZG,EACKE,gBAAIH,UAAYI,IAEhBD,IAC2Bb,EAAcW,GAC1CE,gBAAIH,UAAYI,QCzBjBV,WACXI,EACAC,mBAGQC,iFAEoBK,UACjBR,KACmBQ,UAZrBC,EAAMb,YAAca,EAAMb,YAAeP,EAWvCW,CAELC,EAAaC,EAFRF,CAEqBG,EAASI,YChBrCG,WAIJd,EACAe,OAEMC,EAAiBC,OAAOC,KAAKlB,GAC/BmB,GAAiB,EACrBF,OAAOC,KAAKH,GAAQK,cAAKC,OACjBC,EAAQN,EAAeO,QAAQF,UACtB,IAAXC,GAAgBA,GAASH,GAC3BjB,QAAQsB,iDACsCC,KAAKC,UAC/CX,+BAC2BC,EAC1BW,aAAIC,aAASA,QACbC,KAAK,kDAEH,IAEPV,EAAgBG,GACT,MAKb,SAASK,EAKP3B,EACA8B,EACAC,EACAC,OAEMC,EAAK7B,EAAoBJ,MAEF,iBAAlB8B,EAA4B,KAC/BI,EAAQH,EAAgBD,SAEN,iBAAVI,GAAsBC,MAAMC,QAAQF,GAC9CA,EACAxB,EAAIwB,SAImB,eAAzBG,QAAQC,IAAIC,UACdzB,EAAoBd,EAAa8B,GAItBb,OAAOC,KAAKY,GACbH,aAAKa,OACTC,EAAMR,EAAGO,GAETE,EAAqBZ,EAAcU,WAC7BG,IAARD,EAAmB,MAAO,OACxBR,EAAQH,EAAgBW,EAAKV,SACd,iBAAVE,GAAsBC,MAAMC,QAAQF,GAGtCO,EAAI,GAAIP,GAIRO,EAAIP,SAMJU,WACX5C,mBAGE8B,EACAC,EACAC,SAE2B,iBAAhBhC,GAA6C,iBAAVgC,WACjCpB,OACHiC,EACmB,iBAAhB7C,EACHA,EAAYY,EAAMC,OAClBb,EACA8C,OACMH,IAAVX,GAAwC,iBAAVA,EAC1BA,EAAMpB,EAAMC,OACZmB,SACCL,EAAIkB,EAAGf,EAAeC,EAAiBe,IAGzCnB,EAAI3B,EAAa8B,EAAeC,EAAiBC,KCtGjDL,EAAMiB,WACjB/B,UAAUA,EAAcb,aAAeP"}