{"version":3,"file":"signals.mjs","sources":["../src/index.ts"],"sourcesContent":["import {\n\tuseRef,\n\tuseMemo,\n\tuseEffect,\n\tComponent,\n\ttype FunctionComponent,\n} from \"react\";\nimport React from \"react\";\nimport jsxRuntime from \"react/jsx-runtime\";\nimport jsxRuntimeDev from \"react/jsx-dev-runtime\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\nimport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n} from \"@preact/signals-core\";\nimport type { Effect, JsxRuntimeModule } from \"./internal\";\n\nexport { signal, computed, batch, effect, Signal, type ReadonlySignal };\n\nconst Empty = [] as const;\nconst ReactElemType = Symbol.for(\"react.element\"); // https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\nconst ReactMemoType = Symbol.for(\"react.memo\"); // https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L30\nconst ProxyInstance = new Map<FunctionComponent<any>, FunctionComponent<any>>();\nconst SupportsProxy = typeof Proxy === \"function\";\n\nconst ProxyHandlers = {\n\t/**\n\t * This is a function call trap for functional components.\n\t * When this is called, we know it means React did run 'Component()',\n\t * that means we can use any hooks here to setup our effect and store.\n\t *\n\t * With the native Proxy, all other calls such as access/setting to/of properties will\n\t * be forwarded to the target Component, so we don't need to copy the Component's\n\t * own or inherited properties.\n\t *\n\t * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460\n\t */\n\tapply(Component: FunctionComponent, thisArg: any, argumentsList: any) {\n\t\tconst store = useMemo(createEffectStore, Empty);\n\n\t\tuseSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot);\n\n\t\tconst stop = store.updater._start();\n\n\t\ttry {\n\t\t\tconst children = Component.apply(thisArg, argumentsList);\n\t\t\treturn children;\n\t\t} catch (e) {\n\t\t\t// Re-throwing promises that'll be handled by suspense\n\t\t\t// or an actual error.\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\t// Stop effects in either case before return or throw,\n\t\t\t// Otherwise the effect will leak.\n\t\t\tstop();\n\t\t}\n\t},\n};\n\nfunction ProxyFunctionalComponent(Component: FunctionComponent<any>) {\n\treturn ProxyInstance.get(Component) || WrapWithProxy(Component);\n}\nfunction WrapWithProxy(Component: FunctionComponent<any>) {\n\tif (SupportsProxy) {\n\t\tconst ProxyComponent = new Proxy(Component, ProxyHandlers);\n\n\t\tProxyInstance.set(Component, ProxyComponent);\n\t\tProxyInstance.set(ProxyComponent, ProxyComponent);\n\n\t\treturn ProxyComponent;\n\t}\n\n\t/**\n\t * Emulate a Proxy if environment doesn't support it.\n\t *\n\t * @TODO - unlike Proxy, it's not possible to access the type/Component's\n\t * static properties this way. Not sure if we want to copy all statics here.\n\t * Omitting this for now.\n\t *\n\t * @example - works with Proxy, doesn't with wrapped function.\n\t * ```\n\t * const el = <SomeFunctionalComponent />\n\t * el.type.someOwnOrInheritedProperty;\n\t * el.type.defaultProps;\n\t * ```\n\t */\n\tconst WrappedComponent = function () {\n\t\treturn ProxyHandlers.apply(Component, undefined, arguments);\n\t};\n\tProxyInstance.set(Component, WrappedComponent);\n\tProxyInstance.set(WrappedComponent, WrappedComponent);\n\n\treturn WrappedComponent;\n}\n\n/**\n * A redux-like store whose store value is a positive 32bit integer (a 'version').\n *\n * React subscribes to this store and gets a snapshot of the current 'version',\n * whenever the 'version' changes, we tell React it's time to update the component (call 'onStoreChange').\n *\n * How we achieve this is by creating a binding with an 'effect', when the `effect._callback' is called,\n * we update our store version and tell React to re-render the component ([1] We don't really care when/how React does it).\n *\n * [1]\n * @see https://reactjs.org/docs/hooks-reference.html#usesyncexternalstore\n * @see https://github.com/reactjs/rfcs/blob/main/text/0214-use-sync-external-store.md\n */\nfunction createEffectStore() {\n\tlet updater!: Effect;\n\tlet version = 0;\n\tlet onChangeNotifyReact: (() => void) | undefined;\n\n\tlet unsubscribe = effect(function (this: Effect) {\n\t\tupdater = this;\n\t});\n\tupdater._callback = function () {\n\t\tversion = (version + 1) | 0;\n\t\tif (onChangeNotifyReact) onChangeNotifyReact();\n\t};\n\n\treturn {\n\t\tupdater,\n\t\tsubscribe(onStoreChange: () => void) {\n\t\t\tonChangeNotifyReact = onStoreChange;\n\n\t\t\treturn function () {\n\t\t\t\t/**\n\t\t\t\t * Rotate to next version when unsubscribing to ensure that components are re-run\n\t\t\t\t * when subscribing again.\n\t\t\t\t *\n\t\t\t\t * In StrictMode, 'memo'-ed components seem to keep a stale snapshot version, so\n\t\t\t\t * don't re-run after subscribing again if the version is the same as last time.\n\t\t\t\t *\n\t\t\t\t * Because we unsubscribe from the effect, the version may not change. We simply\n\t\t\t\t * set a new initial version in case of stale snapshots here.\n\t\t\t\t */\n\t\t\t\tversion = (version + 1) | 0;\n\t\t\t\tonChangeNotifyReact = undefined;\n\t\t\t\tunsubscribe();\n\t\t\t};\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn version;\n\t\t},\n\t};\n}\n\nfunction WrapJsx<T>(jsx: T): T {\n\tif (typeof jsx !== \"function\") return jsx;\n\n\treturn function (type: any, props: any, ...rest: any[]) {\n\t\tif (typeof type === \"function\" && !(type instanceof Component)) {\n\t\t\treturn jsx.call(jsx, ProxyFunctionalComponent(type), props, ...rest);\n\t\t}\n\n\t\tif (type && typeof type === \"object\" && type.$$typeof === ReactMemoType) {\n\t\t\ttype.type = ProxyFunctionalComponent(type.type);\n\t\t\treturn jsx.call(jsx, type, props, ...rest);\n\t\t}\n\n\t\tif (typeof type === \"string\" && props) {\n\t\t\tfor (let i in props) {\n\t\t\t\tlet v = props[i];\n\t\t\t\tif (i !== \"children\" && v instanceof Signal) {\n\t\t\t\t\tprops[i] = v.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jsx.call(jsx, type, props, ...rest);\n\t} as any as T;\n}\n\nconst JsxPro: JsxRuntimeModule = jsxRuntime;\nconst JsxDev: JsxRuntimeModule = jsxRuntimeDev;\n\n/**\n * createElement _may_ be called by jsx runtime as a fallback in certain cases,\n * so we need to wrap it regardless.\n *\n * The jsx exports depend on the `NODE_ENV` var to ensure the users' bundler doesn't\n * include both, so one of them will be set with `undefined` values.\n */\nReact.createElement = WrapJsx(React.createElement);\nJsxDev.jsx && /*   */ (JsxDev.jsx = WrapJsx(JsxDev.jsx));\nJsxPro.jsx && /*   */ (JsxPro.jsx = WrapJsx(JsxPro.jsx));\nJsxDev.jsxs && /*  */ (JsxDev.jsxs = WrapJsx(JsxDev.jsxs));\nJsxPro.jsxs && /*  */ (JsxPro.jsxs = WrapJsx(JsxPro.jsxs));\nJsxDev.jsxDEV && /**/ (JsxDev.jsxDEV = WrapJsx(JsxDev.jsxDEV));\nJsxPro.jsxDEV && /**/ (JsxPro.jsxDEV = WrapJsx(JsxPro.jsxDEV));\n\n/**\n * A wrapper component that renders a Signal's value directly as a Text node.\n */\nfunction Text({ data }: { data: Signal }) {\n\treturn data.value;\n}\n\n// Decorate Signals so React renders them as <Text> components.\nObject.defineProperties(Signal.prototype, {\n\t$$typeof: { configurable: true, value: ReactElemType },\n\ttype: { configurable: true, value: ProxyFunctionalComponent(Text) },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\tref: { configurable: true, value: null },\n});\n\nexport function useSignal<T>(value: T) {\n\treturn useMemo(() => signal<T>(value), Empty);\n}\n\nexport function useComputed<T>(compute: () => T) {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\treturn useMemo(() => computed<T>(() => $compute.current()), Empty);\n}\n\nexport function useSignalEffect(cb: () => void | (() => void)) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(() => {\n\t\t\treturn callback.current();\n\t\t});\n\t}, Empty);\n}\n"],"names":["React","Component","useMemo","useRef","useEffect","jsxRuntime","jsxRuntimeDev","useSyncExternalStore","Signal","signal","computed","effect","batch","Empty","Symbol","for","ReactMemoType","ProxyInstance","Map","ProxyHandlers","apply","thisArg","argumentsList","store","createEffectStore","subscribe","getSnapshot","stop","updater","_start","e","get","SupportsProxy","ProxyComponent","Proxy","set","WrappedComponent","undefined","arguments","WrapWithProxy","onChangeNotifyReact","unsubscribe","this","_callback","version","onStoreChange","jsx","type","props","rest","call","ProxyFunctionalComponent","$$typeof","v","i","value","JsxDev","createElement","WrapJsx","JsxPro","jsxs","jsxDEV","Object","defineProperties","prototype","configurable","ReactElemType","data","ref","compute","$compute","current","useSignalEffect","cb","callback","useComputed","useSignal"],"mappings":"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"}