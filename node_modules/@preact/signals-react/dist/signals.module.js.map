{"version":3,"file":"signals.module.js","sources":["../src/index.ts"],"sourcesContent":["import {\n\tuseRef,\n\tuseMemo,\n\tuseEffect,\n\tComponent,\n\ttype FunctionComponent,\n} from \"react\";\nimport React from \"react\";\nimport jsxRuntime from \"react/jsx-runtime\";\nimport jsxRuntimeDev from \"react/jsx-dev-runtime\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim/index.js\";\nimport {\n\tsignal,\n\tcomputed,\n\tbatch,\n\teffect,\n\tSignal,\n\ttype ReadonlySignal,\n} from \"@preact/signals-core\";\nimport type { Effect, JsxRuntimeModule } from \"./internal\";\n\nexport { signal, computed, batch, effect, Signal, type ReadonlySignal };\n\nconst Empty = [] as const;\nconst ReactElemType = Symbol.for(\"react.element\"); // https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L15\nconst ReactMemoType = Symbol.for(\"react.memo\"); // https://github.com/facebook/react/blob/346c7d4c43a0717302d446da9e7423a8e28d8996/packages/shared/ReactSymbols.js#L30\nconst ProxyInstance = new Map<FunctionComponent<any>, FunctionComponent<any>>();\nconst SupportsProxy = typeof Proxy === \"function\";\n\nconst ProxyHandlers = {\n\t/**\n\t * This is a function call trap for functional components.\n\t * When this is called, we know it means React did run 'Component()',\n\t * that means we can use any hooks here to setup our effect and store.\n\t *\n\t * With the native Proxy, all other calls such as access/setting to/of properties will\n\t * be forwarded to the target Component, so we don't need to copy the Component's\n\t * own or inherited properties.\n\t *\n\t * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460\n\t */\n\tapply(Component: FunctionComponent, thisArg: any, argumentsList: any) {\n\t\tconst store = useMemo(createEffectStore, Empty);\n\n\t\tuseSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot);\n\n\t\tconst stop = store.updater._start();\n\n\t\ttry {\n\t\t\tconst children = Component.apply(thisArg, argumentsList);\n\t\t\treturn children;\n\t\t} catch (e) {\n\t\t\t// Re-throwing promises that'll be handled by suspense\n\t\t\t// or an actual error.\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\t// Stop effects in either case before return or throw,\n\t\t\t// Otherwise the effect will leak.\n\t\t\tstop();\n\t\t}\n\t},\n};\n\nfunction ProxyFunctionalComponent(Component: FunctionComponent<any>) {\n\treturn ProxyInstance.get(Component) || WrapWithProxy(Component);\n}\nfunction WrapWithProxy(Component: FunctionComponent<any>) {\n\tif (SupportsProxy) {\n\t\tconst ProxyComponent = new Proxy(Component, ProxyHandlers);\n\n\t\tProxyInstance.set(Component, ProxyComponent);\n\t\tProxyInstance.set(ProxyComponent, ProxyComponent);\n\n\t\treturn ProxyComponent;\n\t}\n\n\t/**\n\t * Emulate a Proxy if environment doesn't support it.\n\t *\n\t * @TODO - unlike Proxy, it's not possible to access the type/Component's\n\t * static properties this way. Not sure if we want to copy all statics here.\n\t * Omitting this for now.\n\t *\n\t * @example - works with Proxy, doesn't with wrapped function.\n\t * ```\n\t * const el = <SomeFunctionalComponent />\n\t * el.type.someOwnOrInheritedProperty;\n\t * el.type.defaultProps;\n\t * ```\n\t */\n\tconst WrappedComponent = function () {\n\t\treturn ProxyHandlers.apply(Component, undefined, arguments);\n\t};\n\tProxyInstance.set(Component, WrappedComponent);\n\tProxyInstance.set(WrappedComponent, WrappedComponent);\n\n\treturn WrappedComponent;\n}\n\n/**\n * A redux-like store whose store value is a positive 32bit integer (a 'version').\n *\n * React subscribes to this store and gets a snapshot of the current 'version',\n * whenever the 'version' changes, we tell React it's time to update the component (call 'onStoreChange').\n *\n * How we achieve this is by creating a binding with an 'effect', when the `effect._callback' is called,\n * we update our store version and tell React to re-render the component ([1] We don't really care when/how React does it).\n *\n * [1]\n * @see https://reactjs.org/docs/hooks-reference.html#usesyncexternalstore\n * @see https://github.com/reactjs/rfcs/blob/main/text/0214-use-sync-external-store.md\n */\nfunction createEffectStore() {\n\tlet updater!: Effect;\n\tlet version = 0;\n\tlet onChangeNotifyReact: (() => void) | undefined;\n\n\tlet unsubscribe = effect(function (this: Effect) {\n\t\tupdater = this;\n\t});\n\tupdater._callback = function () {\n\t\tversion = (version + 1) | 0;\n\t\tif (onChangeNotifyReact) onChangeNotifyReact();\n\t};\n\n\treturn {\n\t\tupdater,\n\t\tsubscribe(onStoreChange: () => void) {\n\t\t\tonChangeNotifyReact = onStoreChange;\n\n\t\t\treturn function () {\n\t\t\t\t/**\n\t\t\t\t * Rotate to next version when unsubscribing to ensure that components are re-run\n\t\t\t\t * when subscribing again.\n\t\t\t\t *\n\t\t\t\t * In StrictMode, 'memo'-ed components seem to keep a stale snapshot version, so\n\t\t\t\t * don't re-run after subscribing again if the version is the same as last time.\n\t\t\t\t *\n\t\t\t\t * Because we unsubscribe from the effect, the version may not change. We simply\n\t\t\t\t * set a new initial version in case of stale snapshots here.\n\t\t\t\t */\n\t\t\t\tversion = (version + 1) | 0;\n\t\t\t\tonChangeNotifyReact = undefined;\n\t\t\t\tunsubscribe();\n\t\t\t};\n\t\t},\n\t\tgetSnapshot() {\n\t\t\treturn version;\n\t\t},\n\t};\n}\n\nfunction WrapJsx<T>(jsx: T): T {\n\tif (typeof jsx !== \"function\") return jsx;\n\n\treturn function (type: any, props: any, ...rest: any[]) {\n\t\tif (typeof type === \"function\" && !(type instanceof Component)) {\n\t\t\treturn jsx.call(jsx, ProxyFunctionalComponent(type), props, ...rest);\n\t\t}\n\n\t\tif (type && typeof type === \"object\" && type.$$typeof === ReactMemoType) {\n\t\t\ttype.type = ProxyFunctionalComponent(type.type);\n\t\t\treturn jsx.call(jsx, type, props, ...rest);\n\t\t}\n\n\t\tif (typeof type === \"string\" && props) {\n\t\t\tfor (let i in props) {\n\t\t\t\tlet v = props[i];\n\t\t\t\tif (i !== \"children\" && v instanceof Signal) {\n\t\t\t\t\tprops[i] = v.value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jsx.call(jsx, type, props, ...rest);\n\t} as any as T;\n}\n\nconst JsxPro: JsxRuntimeModule = jsxRuntime;\nconst JsxDev: JsxRuntimeModule = jsxRuntimeDev;\n\n/**\n * createElement _may_ be called by jsx runtime as a fallback in certain cases,\n * so we need to wrap it regardless.\n *\n * The jsx exports depend on the `NODE_ENV` var to ensure the users' bundler doesn't\n * include both, so one of them will be set with `undefined` values.\n */\nReact.createElement = WrapJsx(React.createElement);\nJsxDev.jsx && /*   */ (JsxDev.jsx = WrapJsx(JsxDev.jsx));\nJsxPro.jsx && /*   */ (JsxPro.jsx = WrapJsx(JsxPro.jsx));\nJsxDev.jsxs && /*  */ (JsxDev.jsxs = WrapJsx(JsxDev.jsxs));\nJsxPro.jsxs && /*  */ (JsxPro.jsxs = WrapJsx(JsxPro.jsxs));\nJsxDev.jsxDEV && /**/ (JsxDev.jsxDEV = WrapJsx(JsxDev.jsxDEV));\nJsxPro.jsxDEV && /**/ (JsxPro.jsxDEV = WrapJsx(JsxPro.jsxDEV));\n\n/**\n * A wrapper component that renders a Signal's value directly as a Text node.\n */\nfunction Text({ data }: { data: Signal }) {\n\treturn data.value;\n}\n\n// Decorate Signals so React renders them as <Text> components.\nObject.defineProperties(Signal.prototype, {\n\t$$typeof: { configurable: true, value: ReactElemType },\n\ttype: { configurable: true, value: ProxyFunctionalComponent(Text) },\n\tprops: {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn { data: this };\n\t\t},\n\t},\n\tref: { configurable: true, value: null },\n});\n\nexport function useSignal<T>(value: T) {\n\treturn useMemo(() => signal<T>(value), Empty);\n}\n\nexport function useComputed<T>(compute: () => T) {\n\tconst $compute = useRef(compute);\n\t$compute.current = compute;\n\treturn useMemo(() => computed<T>(() => $compute.current()), Empty);\n}\n\nexport function useSignalEffect(cb: () => void | (() => void)) {\n\tconst callback = useRef(cb);\n\tcallback.current = cb;\n\n\tuseEffect(() => {\n\t\treturn effect(() => {\n\t\t\treturn callback.current();\n\t\t});\n\t}, Empty);\n}\n"],"names":["Empty","Symbol","ReactMemoType","ProxyInstance","Map","SupportsProxy","Proxy","apply","Component","thisArg","argumentsList","useMemo","createEffectStore","useSyncExternalStore","store","subscribe","getSnapshot","updater","_start","e","stop","ProxyFunctionalComponent","get","ProxyComponent","ProxyHandlers","set","WrappedComponent","undefined","arguments","WrapWithProxy","onChangeNotifyReact","version","unsubscribe","effect","this","_callback","onStoreChange","WrapJsx","jsx","type","props","slice","call","rest","$$typeof","i","v","Signal","value","concat","JsxPro","jsxRuntime","JsxDev","jsxRuntimeDev","React","createElement","jsxs","jsxDEV","Object","defineProperties","prototype","configurable","ReactElemType","_ref","data","ref","useComputed","compute","$compute","useRef","current","computed","useSignalEffect","cb","callback","useEffect","useSignal"],"mappings":"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"}