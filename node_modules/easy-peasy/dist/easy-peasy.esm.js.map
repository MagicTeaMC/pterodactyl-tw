{"version":3,"file":"easy-peasy.esm.js","sources":["../src/context.js","../src/hooks.js","../src/helpers.js","../src/lib.js","../src/create-reducer.js","../src/persistence.js","../src/thunks.js","../src/listeners.js","../src/computed-properties.js","../src/effects.js","../src/create-store.js","../src/create-store-internals.js","../src/extract-data-from-model.js","../src/constants.js","../src/actions.js","../src/create-context-store.js","../src/create-transform.js","../src/provider.js","../src/use-local-store.js"],"sourcesContent":["import { createContext } from 'react';\n\nconst StoreContext = createContext();\n\nexport default StoreContext;\n","import {\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useReducer,\n  useRef,\n  useState,\n} from 'react';\nimport EasyPeasyContext from './context';\n\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nexport function createStoreStateHook(Context) {\n  return function useStoreState(mapState, equalityFn) {\n    const store = useContext(Context);\n    const mapStateRef = useRef(mapState);\n    const stateRef = useRef();\n    const mountedRef = useRef(true);\n    const subscriptionMapStateError = useRef();\n\n    const [, forceRender] = useReducer((s) => s + 1, 0);\n\n    if (\n      subscriptionMapStateError.current ||\n      mapStateRef.current !== mapState ||\n      stateRef.current === undefined\n    ) {\n      try {\n        stateRef.current = mapState(store.getState());\n      } catch (err) {\n        if (process.env.NODE_ENV === 'development') {\n          let errorMessage = `An error occurred trying to map state in a useStoreState hook: ${err.message}.`;\n          if (subscriptionMapStateError.current) {\n            errorMessage += `\\nThis error may be related to the following error:\\n${subscriptionMapStateError.current.stack}\\n\\nOriginal stack trace:`;\n          }\n          throw new Error(errorMessage);\n        }\n        throw subscriptionMapStateError.current || err;\n      }\n    }\n\n    useIsomorphicLayoutEffect(() => {\n      mapStateRef.current = mapState;\n      subscriptionMapStateError.current = undefined;\n    });\n\n    useIsomorphicLayoutEffect(() => {\n      const checkMapState = () => {\n        try {\n          const newState = mapStateRef.current(store.getState());\n\n          const isStateEqual =\n            typeof equalityFn === 'function'\n              ? equalityFn(stateRef.current, newState)\n              : stateRef.current === newState;\n\n          if (isStateEqual) {\n            return;\n          }\n\n          stateRef.current = newState;\n        } catch (err) {\n          // see https://github.com/reduxjs/react-redux/issues/1179\n          // There is a possibility mapState will fail due to stale state or\n          // props, therefore we will just track the error and force our\n          // component to update. It should then receive the updated state\n          subscriptionMapStateError.current = err;\n        }\n        if (mountedRef.current) {\n          forceRender({});\n        }\n      };\n      const unsubscribe = store.subscribe(checkMapState);\n      checkMapState();\n      return () => {\n        mountedRef.current = false;\n        unsubscribe();\n      };\n    }, []);\n\n    return stateRef.current;\n  };\n}\n\nexport const useStoreState = createStoreStateHook(EasyPeasyContext);\n\nexport function createStoreActionsHook(Context) {\n  return function useStoreActions(mapActions) {\n    const store = useContext(Context);\n    return mapActions(store.getActions());\n  };\n}\n\nexport const useStoreActions = createStoreActionsHook(EasyPeasyContext);\n\nexport function createStoreDispatchHook(Context) {\n  return function useStoreDispatch() {\n    const store = useContext(Context);\n    return store.dispatch;\n  };\n}\n\nexport const useStoreDispatch = createStoreDispatchHook(EasyPeasyContext);\n\nexport function useStore() {\n  return useContext(EasyPeasyContext);\n}\n\nexport function createStoreRehydratedHook(Context) {\n  return function useStoreRehydrated() {\n    const store = useContext(Context);\n    const [rehydrated, setRehydrated] = useState(false);\n    useEffect(() => {\n      store.persist.resolveRehydration().then(() => setRehydrated(true));\n    }, []);\n    return rehydrated;\n  };\n}\n\nexport const useStoreRehydrated = createStoreRehydratedHook(EasyPeasyContext);\n\nexport function createTypedHooks() {\n  return {\n    useStoreActions,\n    useStoreDispatch,\n    useStoreState,\n    useStoreRehydrated,\n    useStore,\n  };\n}\n","import { isDraft, current } from 'immer';\nimport memoizerific from 'memoizerific';\nimport {\n  actionOnSymbol,\n  actionSymbol,\n  computedSymbol,\n  effectOnSymbol,\n  persistSymbol,\n  reducerSymbol,\n  thunkOnSymbol,\n  thunkSymbol,\n} from './constants';\n\nexport const debug = (state) => {\n  if (isDraft(state)) {\n    return current(state);\n  }\n  return state;\n};\n\nexport const memo = (fn, cacheSize) => memoizerific(cacheSize)(fn);\n\nexport const actionOn = (targetResolver, fn) => {\n  return {\n    [actionOnSymbol]: true,\n    fn,\n    targetResolver,\n  };\n};\n\nexport const action = (fn) => {\n  return {\n    [actionSymbol]: true,\n    fn,\n  };\n};\n\nconst defaultStateResolvers = [(state) => state];\n\nexport const computed = (fnOrStateResolvers, fn) => {\n  if (typeof fn === 'function') {\n    return {\n      [computedSymbol]: true,\n      fn,\n      stateResolvers: fnOrStateResolvers,\n    };\n  }\n  return {\n    [computedSymbol]: true,\n    fn: fnOrStateResolvers,\n    stateResolvers: defaultStateResolvers,\n  };\n};\n\nexport function unstable_effectOn(dependencyResolvers, fn) {\n  return {\n    [effectOnSymbol]: true,\n    dependencyResolvers,\n    fn,\n  };\n}\n\nexport function generic(value) {\n  return value;\n}\n\nexport const persist = (model, config) => {\n  // if we are not running in a browser context this becomes a no-op\n  return typeof window === 'undefined'\n    ? model\n    : {\n        ...model,\n        [persistSymbol]: config,\n      };\n};\n\nexport const thunkOn = (targetResolver, fn) => {\n  return {\n    [thunkOnSymbol]: true,\n    fn,\n    targetResolver,\n  };\n};\n\nexport const thunk = (fn) => {\n  return {\n    [thunkSymbol]: true,\n    fn,\n  };\n};\n\nexport const reducer = (fn) => {\n  return {\n    [reducerSymbol]: true,\n    fn,\n  };\n};\n","import { isPlainObject } from 'is-plain-object';\nimport { Immer, isDraft } from 'immer';\n\n/**\n * We create our own immer instance to avoid potential issues with autoFreeze\n * becoming default enabled everywhere. We want to disable autofreeze as it\n * does not suit the design of Easy Peasy.\n * https://github.com/immerjs/immer/issues/681#issuecomment-705581111\n */\nconst easyPeasyImmer = new Immer({\n  useProxies: true,\n  autoFreeze: false,\n});\n\nexport const deepCloneStateWithoutComputed = (source) => {\n  const recursiveClone = (current) => {\n    const next = Object.keys(current).reduce((acc, key) => {\n      if (Object.getOwnPropertyDescriptor(current, key).get == null) {\n        acc[key] = current[key];\n      }\n      return acc;\n    }, {});\n    Object.keys(next).forEach((key) => {\n      if (isPlainObject(next[key])) {\n        next[key] = recursiveClone(next[key]);\n      }\n    });\n    return next;\n  };\n  return recursiveClone(source);\n};\n\nexport const isPromise = (x) => {\n  return x != null && typeof x === 'object' && typeof x.then === 'function';\n};\n\nexport function get(path, target) {\n  return path.reduce((acc, cur) => {\n    return isPlainObject(acc) ? acc[cur] : undefined;\n  }, target);\n}\n\nexport function newify(currentPath, currentState, finalValue) {\n  if (currentPath.length === 0) {\n    return finalValue;\n  }\n  const newState = { ...currentState };\n  const key = currentPath[0];\n  if (currentPath.length === 1) {\n    newState[key] = finalValue;\n  } else {\n    newState[key] = newify(currentPath.slice(1), newState[key], finalValue);\n  }\n  return newState;\n}\n\nexport const set = (path, target, value) => {\n  if (path.length === 0) {\n    if (typeof value === 'object') {\n      Object.keys(target).forEach((key) => {\n        delete target[key];\n      });\n      Object.keys(value).forEach((key) => {\n        target[key] = value[key];\n      });\n    }\n    return;\n  }\n  path.reduce((acc, cur, idx) => {\n    if (idx + 1 === path.length) {\n      acc[cur] = value;\n    } else {\n      acc[cur] = acc[cur] || {};\n    }\n    return acc[cur];\n  }, target);\n};\n\nexport function createSimpleProduce(disableImmer = false) {\n  return function simpleProduce(path, state, fn) {\n    if (disableImmer) {\n      const current = get(path, state);\n      const next = fn(current);\n      if (current !== next) {\n        return newify(path, state, next);\n      }\n      return state;\n    }\n    if (path.length === 0) {\n      const draft = easyPeasyImmer.createDraft(state);\n      const result = fn(draft);\n      if (result) {\n        return isDraft(result) ? easyPeasyImmer.finishDraft(result) : result;\n      }\n      return easyPeasyImmer.finishDraft(draft);\n    }\n    const parentPath = path.slice(0, path.length - 1);\n    const draft = easyPeasyImmer.createDraft(state);\n    const parent = get(parentPath, state);\n    const current = get(path, draft);\n    const result = fn(current);\n\n    if (result) {\n      parent[path[path.length - 1]] = result;\n    }\n    return easyPeasyImmer.finishDraft(draft);\n  };\n}\n\nconst pReduce = (iterable, reducer, initialValue) =>\n  new Promise((resolve, reject) => {\n    const iterator = iterable[Symbol.iterator]();\n    let index = 0;\n\n    const next = async (total) => {\n      const element = iterator.next();\n\n      if (element.done) {\n        resolve(total);\n        return;\n      }\n\n      try {\n        const value = await Promise.all([total, element.value]);\n        // eslint-disable-next-line no-plusplus\n        next(reducer(value[0], value[1], index++));\n      } catch (error) {\n        reject(error);\n      }\n    };\n\n    next(initialValue);\n  });\n\nexport const pSeries = async (tasks) => {\n  const results = [];\n\n  await pReduce(tasks, async (_, task) => {\n    const value = await task();\n    results.push(value);\n  });\n\n  return results;\n};\n","import { createSimpleProduce, get } from './lib';\n\nexport default function createReducer(\n  disableImmer,\n  _actionReducersDict,\n  _customReducers,\n  _computedProperties,\n) {\n  const simpleProduce = createSimpleProduce(disableImmer);\n\n  const runActionReducerAtPath = (state, action, actionReducer, path) => {\n    return simpleProduce(path, state, (draft) =>\n      actionReducer(draft, action.payload),\n    );\n  };\n\n  const reducerForActions = (state, action) => {\n    const actionReducer = _actionReducersDict[action.type];\n    if (actionReducer) {\n      return runActionReducerAtPath(\n        state,\n        action,\n        actionReducer,\n        actionReducer.definition.meta.parent,\n      );\n    }\n    return state;\n  };\n\n  const reducerForCustomReducers = (state, action) => {\n    return _customReducers.reduce((acc, { parentPath, key, reducer: red }) => {\n      return simpleProduce(parentPath, acc, (draft) => {\n        draft[key] = red(draft[key], action);\n        return draft;\n      });\n    }, state);\n  };\n\n  const rootReducer = (state, action) => {\n    const stateAfterActions = reducerForActions(state, action);\n    const next =\n      _customReducers.length > 0\n        ? reducerForCustomReducers(stateAfterActions, action)\n        : stateAfterActions;\n    if (state !== next) {\n      _computedProperties.forEach(({ parentPath, bindComputedProperty }) => {\n        const parentState = get(parentPath, next);\n        if (parentState != null) bindComputedProperty(parentState, next);\n      });\n    }\n    return next;\n  };\n\n  return rootReducer;\n}\n","import { isPlainObject } from 'is-plain-object';\nimport {\n  deepCloneStateWithoutComputed,\n  get,\n  isPromise,\n  set,\n  pSeries,\n} from './lib';\n\nconst noopStorage = {\n  getItem: () => undefined,\n  setItem: () => undefined,\n  removeItem: () => undefined,\n};\n\nconst getBrowerStorage = (storageName) => {\n  let storageCache;\n  return () => {\n    if (!storageCache) {\n      try {\n        if (\n          typeof window !== 'undefined' &&\n          typeof window[storageName] !== 'undefined'\n        ) {\n          storageCache = window[storageName];\n        }\n      } catch (_) {\n        // swallow the failure\n      }\n      if (!storageCache) {\n        storageCache = noopStorage;\n      }\n    }\n\n    return storageCache;\n  };\n};\n\nconst localStorage = getBrowerStorage('localStorage');\nconst sessionStorage = getBrowerStorage('sessionStorage');\n\nfunction createStorageWrapper(storage, transformers = []) {\n  if (storage == null) {\n    storage = sessionStorage();\n  }\n\n  if (typeof storage === 'string') {\n    if (storage === 'localStorage') {\n      storage = localStorage();\n    } else if (storage === 'sessionStorage') {\n      storage = sessionStorage();\n    } else {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(\n          `Invalid storage provider specified for Easy Peasy persist: ${storage}\\nValid values include \"localStorage\", \"sessionStorage\" or a custom storage engine.`,\n        );\n      }\n      storage = noopStorage;\n    }\n  }\n\n  const outTransformers = [...transformers].reverse();\n\n  const serialize = (data) => {\n    if (transformers.length > 0 && data != null && typeof data === 'object') {\n      Object.keys(data).forEach((key) => {\n        data[key] = transformers.reduce((acc, cur) => {\n          return cur.in(acc, key);\n        }, data[key]);\n      });\n    }\n\n    return storage === localStorage() || storage === sessionStorage()\n      ? JSON.stringify({ data })\n      : data;\n  };\n\n  const deserialize = (data) => {\n    const result =\n      storage === localStorage() || storage === sessionStorage()\n        ? JSON.parse(data).data\n        : data;\n    if (\n      outTransformers.length > 0 &&\n      result != null &&\n      typeof result === 'object'\n    ) {\n      Object.keys(result).forEach((key) => {\n        result[key] = outTransformers.reduce((acc, cur) => {\n          return cur.out(acc, key);\n        }, result[key]);\n      });\n    }\n    return result;\n  };\n\n  const isAsync = isPromise(storage.getItem('_'));\n\n  return {\n    isAsync,\n    getItem: (key) => {\n      if (isAsync) {\n        return storage.getItem(key).then((wrapped) => {\n          return wrapped != null ? deserialize(wrapped) : undefined;\n        });\n      }\n      const wrapped = storage.getItem(key);\n      return wrapped != null ? deserialize(wrapped) : undefined;\n    },\n    setItem: (key, data) => {\n      return storage.setItem(key, serialize(data));\n    },\n    removeItem: (key) => {\n      return storage.removeItem(key);\n    },\n  };\n}\n\nexport function extractPersistConfig(path, persistDefinition = {}) {\n  return {\n    path,\n    config: {\n      allow: persistDefinition.allow || [],\n      deny: persistDefinition.deny || [],\n      mergeStrategy: persistDefinition.mergeStrategy || 'mergeDeep',\n      storage: createStorageWrapper(\n        persistDefinition.storage,\n        persistDefinition.transformers,\n      ),\n    },\n  };\n}\n\nfunction resolvePersistTargets(target, allow, deny) {\n  let targets = Object.keys(target);\n  if (allow.length > 0) {\n    targets = targets.reduce((acc, cur) => {\n      if (allow.findIndex((x) => x === cur) !== -1) {\n        return [...acc, cur];\n      }\n      return acc;\n    }, []);\n  }\n  if (deny.length > 0) {\n    targets = targets.reduce((acc, cur) => {\n      if (deny.findIndex((x) => x === cur) !== -1) {\n        return acc;\n      }\n      return [...acc, cur];\n    }, []);\n  }\n  return targets;\n}\n\nfunction createPersistenceClearer(persistKey, references) {\n  return () => {\n    if (references.internals._persistenceConfig.length === 0) {\n      return Promise.resolve();\n    }\n    return pSeries(\n      references.internals._persistenceConfig.map(({ path, config }) => () =>\n        Promise.resolve(config.storage.removeItem(persistKey(path))),\n      ),\n    );\n  };\n}\n\nexport function createPersistor(persistKey, references) {\n  let persistPromise = Promise.resolve();\n  let isPersisting = false;\n  let nextPersistOperation;\n\n  const timingMethod =\n    typeof window === 'undefined'\n      ? (fn) => fn()\n      : window.requestIdleCallback != null\n      ? window.requestIdleCallback\n      : window.requestAnimationFrame;\n\n  const persist = (nextState) => {\n    if (references.internals._persistenceConfig.length === 0) {\n      return;\n    }\n\n    const operation = () => {\n      isPersisting = true;\n      persistPromise = new Promise((resolve) => {\n        timingMethod(() => {\n          pSeries(\n            references.internals._persistenceConfig.map(\n              ({ path, config }) => () => {\n                const { storage, allow, deny } = config;\n                const persistRootState = deepCloneStateWithoutComputed(\n                  get(path, nextState),\n                );\n                const persistTargets = resolvePersistTargets(\n                  persistRootState,\n                  allow,\n                  deny,\n                );\n                const stateToPersist = {};\n                persistTargets.map((key) => {\n                  const targetPath = [...path, key];\n                  const rawValue = get(targetPath, nextState);\n                  const value = isPlainObject(rawValue)\n                    ? deepCloneStateWithoutComputed(rawValue)\n                    : rawValue;\n                  stateToPersist[key] = value;\n                });\n                return Promise.resolve(\n                  storage.setItem(persistKey(path), stateToPersist),\n                );\n              },\n            ),\n          ).finally(() => {\n            isPersisting = false;\n            if (nextPersistOperation) {\n              const next = nextPersistOperation;\n              nextPersistOperation = null;\n              next();\n            } else {\n              resolve();\n            }\n          });\n        });\n      });\n    };\n\n    if (isPersisting) {\n      nextPersistOperation = operation;\n    } else {\n      operation();\n    }\n  };\n\n  return {\n    persist,\n    clear: createPersistenceClearer(persistKey, references),\n    flush: async () => {\n      if (nextPersistOperation) {\n        nextPersistOperation();\n      }\n      await persistPromise;\n    },\n  };\n}\n\nexport function createPersistMiddleware(persistor, references) {\n  return ({ getState }) => (next) => (action) => {\n    const state = next(action);\n    if (\n      action &&\n      action.type !== '@action.ePRS' &&\n      references.internals._persistenceConfig.length > 0\n    ) {\n      persistor.persist(getState());\n    }\n    return state;\n  };\n}\n\nexport function rehydrateStateFromPersistIfNeeded(\n  persistKey,\n  replaceState,\n  references,\n  root,\n) {\n  if (references.internals._persistenceConfig.length === 0) {\n    return Promise.resolve();\n  }\n\n  return pSeries(\n    references.internals._persistenceConfig.map((persistInstance) => () => {\n      const { path, config } = persistInstance;\n      const { mergeStrategy, storage } = config;\n\n      if (root && (path.length < 1 || path[0] !== root)) {\n        return Promise.resolve();\n      }\n\n      const state = references.internals._defaultState;\n\n      const hasDataModelChanged = (dataModel, rehydratingModelData) =>\n        dataModel != null &&\n        rehydratingModelData != null &&\n        (typeof dataModel !== typeof rehydratingModelData ||\n          (Array.isArray(dataModel) && !Array.isArray(rehydratingModelData)));\n\n      const applyRehydrationStrategy = (originalState, persistedState) => {\n        if (mergeStrategy === 'overwrite') {\n          set(path, originalState, persistedState);\n        } else if (mergeStrategy === 'mergeShallow') {\n          const targetState = get(path, originalState);\n          Object.keys(persistedState).forEach((key) => {\n            if (hasDataModelChanged(targetState[key], persistedState[key])) {\n              // skip as the data model type has changed since the data was persisted\n            } else {\n              targetState[key] = persistedState[key];\n            }\n          });\n        } else if (mergeStrategy === 'mergeDeep') {\n          const targetState = get(path, originalState);\n          const setAt = (currentTargetState, currentPersistedState) => {\n            Object.keys(currentPersistedState).forEach((key) => {\n              if (\n                hasDataModelChanged(\n                  currentTargetState[key],\n                  currentPersistedState[key],\n                )\n              ) {\n                // skip as the data model type has changed since the data was persisted\n              } else if (isPlainObject(currentPersistedState[key])) {\n                currentTargetState[key] = currentTargetState[key] || {};\n                setAt(currentTargetState[key], currentPersistedState[key]);\n              } else {\n                currentTargetState[key] = currentPersistedState[key];\n              }\n            });\n          };\n          setAt(targetState, persistedState);\n        }\n      };\n\n      const rehydate = (persistedState) => {\n        if (persistedState != null) {\n          applyRehydrationStrategy(state, persistedState);\n        }\n        replaceState(state);\n      };\n\n      const getItemResult = storage.getItem(persistKey(path));\n      if (isPromise(getItemResult)) {\n        return getItemResult.then(rehydate);\n      }\n      return Promise.resolve(rehydate(getItemResult));\n    }),\n  );\n}\n","import { thunkOnSymbol } from './constants';\nimport { get, isPromise } from './lib';\n\nexport function createThunkHandler(\n  definition,\n  references,\n  injections,\n  _actionCreators,\n) {\n  return (payload, fail) => {\n    const helpers = {\n      dispatch: references.dispatch,\n      fail,\n      getState: () => get(definition.meta.parent, references.getState()),\n      getStoreActions: () => _actionCreators,\n      getStoreState: references.getState,\n      injections,\n      meta: {\n        key: definition.meta.actionName,\n        parent: definition.meta.parent,\n        path: definition.meta.path,\n      },\n    };\n    if (definition[thunkOnSymbol] && definition.meta.resolvedTargets) {\n      payload.resolvedTargets = [...definition.meta.resolvedTargets];\n    }\n    return definition.fn(\n      get(definition.meta.parent, _actionCreators),\n      payload,\n      helpers,\n    );\n  };\n}\n\nconst logThunkEventListenerError = (type, err) => {\n  // eslint-disable-next-line no-console\n  console.log(`An error occurred in a listener for ${type}`);\n  // eslint-disable-next-line no-console\n  console.log(err);\n};\n\nconst handleEventDispatchErrors = (type, dispatcher) => (...args) => {\n  try {\n    const result = dispatcher(...args);\n    if (isPromise(result)) {\n      result.catch((err) => {\n        logThunkEventListenerError(type, err);\n      });\n    }\n  } catch (err) {\n    logThunkEventListenerError(type, err);\n  }\n};\n\nexport function createThunkActionsCreator(definition, references) {\n  const actionCreator = (payload) => {\n    const dispatchStart = handleEventDispatchErrors(\n      definition.meta.startType,\n      () =>\n        references.dispatch({\n          type: definition.meta.startType,\n          payload,\n        }),\n    );\n\n    const dispatchFail = handleEventDispatchErrors(\n      definition.meta.failType,\n      (err) =>\n        references.dispatch({\n          type: definition.meta.failType,\n          payload,\n          error: err,\n        }),\n    );\n\n    const dispatchSuccess = handleEventDispatchErrors(\n      definition.meta.successType,\n      (result) =>\n        references.dispatch({\n          type: definition.meta.successType,\n          payload,\n          result,\n        }),\n    );\n\n    dispatchStart();\n\n    let failure = null;\n\n    const fail = (_failure) => {\n      failure = _failure;\n    };\n\n    const result = references.dispatch(() =>\n      definition.thunkHandler(payload, fail),\n    );\n\n    if (isPromise(result)) {\n      return result.then((resolved) => {\n        if (failure) {\n          dispatchFail(failure);\n        } else {\n          dispatchSuccess(resolved);\n        }\n        return resolved;\n      });\n    }\n\n    if (failure) {\n      dispatchFail(failure);\n    } else {\n      dispatchSuccess(result);\n    }\n\n    return result;\n  };\n\n  actionCreator.type = definition.meta.type;\n  actionCreator.successType = definition.meta.successType;\n  actionCreator.failType = definition.meta.failType;\n  actionCreator.startType = definition.meta.startType;\n\n  return actionCreator;\n}\n","import { get } from './lib';\n\nexport function createListenerMiddleware(references) {\n  return () => (next) => (action) => {\n    const result = next(action);\n    if (\n      action &&\n      references.internals._listenerActionMap[action.type] &&\n      references.internals._listenerActionMap[action.type].length > 0\n    ) {\n      const sourceAction = references.internals._actionCreatorDict[action.type];\n      references.internals._listenerActionMap[action.type].forEach(\n        (actionCreator) => {\n          actionCreator({\n            type: sourceAction\n              ? sourceAction.definition.meta.type\n              : action.type,\n            payload: action.payload,\n            error: action.error,\n            result: action.result,\n          });\n        },\n      );\n    }\n    return result;\n  };\n}\n\nexport function bindListenerDefinitions(\n  listenerDefinitions,\n  _actionCreators,\n  _actionCreatorDict,\n  _listenerActionMap,\n) {\n  listenerDefinitions.forEach((definition) => {\n    const targets = definition.targetResolver(\n      get(definition.meta.parent, _actionCreators),\n      _actionCreators,\n    );\n\n    const targetTypes = (Array.isArray(targets) ? targets : [targets]).reduce(\n      (acc, target) => {\n        if (\n          typeof target === 'function' &&\n          target.definition.meta.type &&\n          _actionCreatorDict[target.definition.meta.type]\n        ) {\n          if (target.definition.meta.successType) {\n            acc.push(target.definition.meta.successType);\n            acc.push(target.definition.meta.failType);\n          } else {\n            acc.push(target.definition.meta.type);\n          }\n        } else if (typeof target === 'string') {\n          acc.push(target);\n        }\n        return acc;\n      },\n      [],\n    );\n\n    definition.meta.resolvedTargets = targetTypes;\n\n    targetTypes.forEach((targetType) => {\n      const listenerReg = _listenerActionMap[targetType] || [];\n      listenerReg.push(_actionCreatorDict[definition.meta.type]);\n      _listenerActionMap[targetType] = listenerReg;\n    });\n  });\n}\n","import memoizerific from 'memoizerific';\nimport { get } from './lib';\n\nexport function createComputedPropertyBinder(\n  parentPath,\n  key,\n  definition,\n  _computedState,\n  references,\n) {\n  const memoisedResultFn = memoizerific(1)(definition.fn);\n  return function createComputedProperty(parentState, storeState) {\n    Object.defineProperty(parentState, key, {\n      configurable: true,\n      enumerable: true,\n      get: () => {\n        const state = get(parentPath, storeState);\n        const inputs = definition.stateResolvers.map((resolver) =>\n          resolver(state, storeState),\n        );\n        return memoisedResultFn(...inputs);\n      },\n    });\n  };\n}\n\nexport function createComputedPropertiesMiddleware(references) {\n  return (store) => (next) => (action) => {\n    references.internals._computedState.currentState = store.getState();\n    references.internals._computedState.isInReducer = true;\n    return next(action);\n  };\n}\n","import { get, isPromise } from './lib';\n\nexport function createEffectsMiddleware(references) {\n  return (store) => (next) => (action) => {\n    if (references.internals._effects.length === 0) {\n      return next(action);\n    }\n    const prevState = store.getState();\n    const result = next(action);\n    const nextState = store.getState();\n    references.internals._effects.forEach((definition) => {\n      const prevLocal = get(definition.meta.parent, prevState);\n      const nextLocal = get(definition.meta.parent, nextState);\n      if (prevLocal !== nextLocal) {\n        const prevDependencies = definition.dependencyResolvers.map(\n          (resolver) => resolver(prevLocal),\n        );\n        const nextDependencies = definition.dependencyResolvers.map(\n          (resolver) => resolver(nextLocal),\n        );\n        const hasChanged = prevDependencies.some((dependency, idx) => {\n          return dependency !== nextDependencies[idx];\n        });\n        if (hasChanged) {\n          definition.actionCreator(prevDependencies, nextDependencies, action);\n        }\n      }\n    });\n    return result;\n  };\n}\n\nconst logEffectError = (err) => {\n  // As users can't get a handle on effects we need to report the error\n  // eslint-disable-next-line no-console\n  console.log(err);\n};\n\nexport function createEffectHandler(\n  definition,\n  references,\n  injections,\n  _actionCreators,\n) {\n  const actions = get(definition.meta.parent, _actionCreators);\n\n  let dispose;\n\n  return (change) => {\n    const helpers = {\n      dispatch: references.dispatch,\n      getState: () => get(definition.meta.parent, references.getState()),\n      getStoreActions: () => _actionCreators,\n      getStoreState: references.getState,\n      injections,\n      meta: {\n        key: definition.meta.actionName,\n        parent: definition.meta.parent,\n        path: definition.meta.path,\n      },\n    };\n\n    if (dispose !== undefined) {\n      const disposeResult = dispose();\n      dispose = undefined;\n      if (isPromise(disposeResult)) {\n        disposeResult.catch(logEffectError);\n      }\n    }\n\n    const effectResult = definition.fn(actions, change, helpers);\n\n    if (isPromise(effectResult)) {\n      return effectResult.then((resolved) => {\n        if (typeof resolved === 'function') {\n          if (process.env.NODE_ENV !== 'production') {\n            // Dispose functions are not allowed to be resolved asynchronously.\n            // Doing so would provide inconsistent behaviour around their execution.\n            // eslint-disable-next-line no-console\n            console.warn(\n              '[easy-peasy] You have an effect which is asynchronously resolving a dispose function. This is considered an anti-pattern. Please read the API documentation for more information.',\n            );\n          }\n        }\n      });\n    }\n\n    if (typeof effectResult === 'function') {\n      dispose = effectResult;\n    }\n\n    return undefined;\n  };\n}\n\nconst logEffectEventListenerError = (type, err) => {\n  // eslint-disable-next-line no-console\n  console.log(`An error occurred in a listener for ${type}`);\n  // eslint-disable-next-line no-console\n  console.log(err);\n};\n\nconst handleEventDispatchErrors = (type, dispatcher) => (...args) => {\n  try {\n    const result = dispatcher(...args);\n    if (isPromise(result)) {\n      result.catch((err) => {\n        logEffectEventListenerError(type, err);\n      });\n    }\n  } catch (err) {\n    logEffectEventListenerError(type, err);\n  }\n};\n\nexport function createEffectActionsCreator(\n  definition,\n  references,\n  effectHandler,\n) {\n  const actionCreator = (previousDependencies, nextDependencies, action) => {\n    const change = {\n      prev: previousDependencies,\n      current: nextDependencies,\n      action,\n    };\n\n    const dispatchStart = handleEventDispatchErrors(\n      definition.meta.startType,\n      () =>\n        references.dispatch({\n          type: definition.meta.startType,\n          change,\n        }),\n    );\n\n    const dispatchSuccess = handleEventDispatchErrors(\n      definition.meta.successType,\n      () =>\n        references.dispatch({\n          type: definition.meta.successType,\n          change,\n        }),\n    );\n\n    dispatchStart();\n\n    try {\n      const result = references.dispatch(() => effectHandler(change));\n\n      if (isPromise(result)) {\n        return result.then((resolved) => {\n          dispatchSuccess(resolved);\n          return resolved;\n        }, logEffectError);\n      }\n\n      dispatchSuccess(result);\n\n      return result;\n    } catch (err) {\n      logEffectError(err);\n    }\n  };\n\n  actionCreator.type = definition.meta.type;\n  actionCreator.startType = definition.meta.startType;\n  actionCreator.successType = definition.meta.successType;\n  actionCreator.failType = definition.meta.failType;\n\n  return actionCreator;\n}\n","import {\n  applyMiddleware,\n  compose as reduxCompose,\n  createStore as reduxCreateStore,\n} from 'redux';\nimport reduxThunk from 'redux-thunk';\nimport * as helpers from './helpers';\nimport createStoreInternals from './create-store-internals';\nimport {\n  createPersistor,\n  createPersistMiddleware,\n  rehydrateStateFromPersistIfNeeded,\n} from './persistence';\nimport { createComputedPropertiesMiddleware } from './computed-properties';\nimport { createListenerMiddleware } from './listeners';\nimport { deepCloneStateWithoutComputed } from './lib';\nimport { createEffectsMiddleware } from './effects';\n\nexport default function createStore(model, options = {}) {\n  const modelClone = deepCloneStateWithoutComputed(model);\n  const {\n    compose,\n    devTools = process.env.NODE_ENV !== 'production',\n    disableImmer = false,\n    enhancers = [],\n    initialState = {},\n    injections = {},\n    middleware = [],\n    mockActions = false,\n    name: storeName = `EasyPeasyStore`,\n    version = 0,\n    reducerEnhancer = (rootReducer) => rootReducer,\n  } = options;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof injections !== 'object') {\n      throw new Error('[easy-peasy] Store injections must be an object');\n    }\n  }\n\n  const bindReplaceState = (modelDef) => {\n    return {\n      ...modelDef,\n      ePRS: helpers.action((_, payload) => payload),\n    };\n  };\n\n  const references = {};\n\n  let modelDefinition = bindReplaceState(modelClone);\n  let mockedActions = [];\n\n  const persistKey = (targetPath) =>\n    `[${storeName}][${version}]${\n      targetPath.length > 0 ? `[${targetPath.join('.')}]` : ''\n    }`;\n  const persistor = createPersistor(persistKey, references);\n  const persistMiddleware = createPersistMiddleware(persistor, references);\n\n  const replaceState = (nextState) =>\n    references.internals._actionCreatorDict['@action.ePRS'](nextState);\n\n  const bindStoreInternals = (state = {}) => {\n    references.internals = createStoreInternals({\n      disableImmer,\n      initialState: state,\n      injections,\n      model: modelDefinition,\n      reducerEnhancer,\n      references,\n    });\n  };\n\n  const mockActionsMiddleware = () => () => (action) => {\n    if (action != null) {\n      mockedActions.push(action);\n    }\n    return undefined;\n  };\n\n  const composeEnhancers =\n    compose ||\n    (devTools &&\n    typeof window !== 'undefined' &&\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({\n          name: storeName,\n        })\n      : reduxCompose);\n\n  bindStoreInternals(initialState);\n\n  const easyPeasyMiddleware = [\n    createComputedPropertiesMiddleware(references),\n    ...middleware,\n    reduxThunk,\n    createListenerMiddleware(references),\n    createEffectsMiddleware(references),\n    persistMiddleware,\n  ];\n\n  if (mockActions) {\n    easyPeasyMiddleware.push(mockActionsMiddleware);\n  }\n\n  const store = reduxCreateStore(\n    references.internals.reducer,\n    references.internals._defaultState,\n    composeEnhancers(applyMiddleware(...easyPeasyMiddleware), ...enhancers),\n  );\n\n  store.subscribe(() => {\n    references.internals._computedState.isInReducer = false;\n  });\n\n  references.dispatch = store.dispatch;\n  references.getState = store.getState;\n\n  const bindActionCreators = () => {\n    Object.keys(store.dispatch).forEach((actionsKey) => {\n      delete store.dispatch[actionsKey];\n    });\n    Object.keys(references.internals._actionCreators).forEach((key) => {\n      store.dispatch[key] = references.internals._actionCreators[key];\n    });\n  };\n\n  bindActionCreators();\n\n  const rebindStore = (removeKey) => {\n    const currentState = store.getState();\n    if (removeKey) {\n      delete currentState[removeKey];\n    }\n    bindStoreInternals(currentState);\n    store.replaceReducer(references.internals.reducer);\n    replaceState(references.internals._defaultState);\n    bindActionCreators();\n  };\n\n  const resolveRehydration = rehydrateStateFromPersistIfNeeded(\n    persistKey,\n    replaceState,\n    references,\n  );\n\n  return Object.assign(store, {\n    addModel: (key, modelForKey) => {\n      if (modelDefinition[key] && process.env.NODE_ENV !== 'production') {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `easy-peasy: The store model already contains a model definition for \"${key}\"`,\n        );\n        store.removeModel(key);\n      }\n      modelDefinition[key] = modelForKey;\n      rebindStore();\n      // There may have been persisted state for a dynamic model. We should try\n      // and rehydrate the specifc node\n      const addModelRehydration = rehydrateStateFromPersistIfNeeded(\n        persistKey,\n        replaceState,\n        references,\n        key,\n      );\n      return {\n        resolveRehydration: () => addModelRehydration,\n      };\n    },\n    clearMockedActions: () => {\n      mockedActions = [];\n    },\n    getActions: () => references.internals._actionCreators,\n    getListeners: () => references.internals._listenerActionCreators,\n    getMockedActions: () => [...mockedActions],\n    persist: {\n      clear: persistor.clear,\n      flush: persistor.flush,\n      resolveRehydration: () => resolveRehydration,\n    },\n    reconfigure: (newModel) => {\n      modelDefinition = bindReplaceState(newModel);\n      rebindStore();\n    },\n    removeModel: (key) => {\n      if (!modelDefinition[key]) {\n        if (process.env.NODE_ENV !== 'production') {\n          // eslint-disable-next-line no-console\n          console.warn(\n            `easy-peasy: The store model does not contain a model definition for \"${key}\"`,\n          );\n        }\n        return;\n      }\n      delete modelDefinition[key];\n      rebindStore(key);\n    },\n  });\n}\n","import createReducer from './create-reducer';\nimport extractDataFromModel from './extract-data-from-model';\n\nexport default function createStoreInternals({\n  disableImmer,\n  initialState,\n  injections,\n  model,\n  reducerEnhancer,\n  references,\n}) {\n  const {\n    _actionCreatorDict,\n    _actionCreators,\n    _actionReducersDict,\n    _computedState,\n    _computedProperties,\n    _customReducers,\n    _defaultState,\n    _effects,\n    _listenerActionCreators,\n    _listenerActionMap,\n    _persistenceConfig,\n  } = extractDataFromModel(model, initialState, injections, references);\n\n  const rootReducer = createReducer(\n    disableImmer,\n    _actionReducersDict,\n    _customReducers,\n    _computedProperties,\n  );\n\n  return {\n    _actionCreatorDict,\n    _actionCreators,\n    _computedProperties,\n    _computedState,\n    _defaultState,\n    _effects,\n    _listenerActionCreators,\n    _listenerActionMap,\n    _persistenceConfig,\n    reducer: reducerEnhancer(rootReducer),\n  };\n}\n","import { isPlainObject } from 'is-plain-object';\nimport {\n  actionOnSymbol,\n  actionSymbol,\n  computedSymbol,\n  effectOnSymbol,\n  persistSymbol,\n  reducerSymbol,\n  thunkOnSymbol,\n  thunkSymbol,\n} from './constants';\nimport { get, set } from './lib';\nimport { extractPersistConfig } from './persistence';\nimport { createActionCreator } from './actions';\nimport { createThunkHandler, createThunkActionsCreator } from './thunks';\nimport { bindListenerDefinitions } from './listeners';\nimport { createComputedPropertyBinder } from './computed-properties';\nimport { createEffectHandler, createEffectActionsCreator } from './effects';\n\nexport default function extractDataFromModel(\n  model,\n  initialState,\n  injections,\n  references,\n) {\n  const _defaultState = initialState;\n  const _actionCreatorDict = {};\n  const _actionCreators = {};\n  const _actionReducersDict = {};\n  const actionThunks = {};\n  const _computedProperties = [];\n  const _customReducers = [];\n  const _effects = [];\n  const _listenerActionCreators = {};\n  const _listenerActionMap = {};\n  const listenerDefinitions = [];\n  let _persistenceConfig = [];\n  const _computedState = {\n    isInReducer: false,\n    currentState: _defaultState,\n  };\n\n  const recursiveExtractFromModel = (current, parentPath) =>\n    Object.keys(current).forEach((key) => {\n      const value = current[key];\n      const path = [...parentPath, key];\n      const meta = {\n        parent: parentPath,\n        path,\n        key,\n      };\n      const handleValueAsState = () => {\n        const initialParentRef = get(parentPath, initialState);\n        if (initialParentRef && key in initialParentRef) {\n          set(path, _defaultState, initialParentRef[key]);\n        } else {\n          set(path, _defaultState, value);\n        }\n      };\n\n      if (key === persistSymbol) {\n        _persistenceConfig.push(extractPersistConfig(parentPath, value));\n        return;\n      }\n\n      if (value != null && typeof value === 'object') {\n        if (value[actionSymbol] || value[actionOnSymbol]) {\n          const definition = { ...value };\n\n          // Determine the category of the action\n          const category = definition[actionSymbol] ? '@action' : '@actionOn';\n\n          // Establish the meta data describing the action\n          definition.meta = {\n            actionName: meta.key,\n            category,\n            type: `${category}.${meta.path.join('.')}`,\n            parent: meta.parent,\n            path: meta.path,\n          };\n\n          // Create the \"action creator\" function\n          definition.actionCreator = createActionCreator(\n            definition,\n            references,\n          );\n\n          // Create a bidirectional relationship of the definition/actionCreator\n          definition.actionCreator.definition = definition;\n\n          // Create a bidirectional relationship of the definition/reducer\n          definition.fn.definition = definition;\n\n          // Add the action creator to lookup map\n          _actionCreatorDict[definition.meta.type] = definition.actionCreator;\n\n          // Add the reducer to lookup map\n          _actionReducersDict[definition.meta.type] = definition.fn;\n\n          // We don't want to expose the internal action to consumers\n          if (meta.key !== 'ePRS') {\n            // Set the action creator in the \"actions\" object tree for\n            // either the listeners object tree, or the standard actions/thunks\n            // object tree\n            if (definition[actionOnSymbol]) {\n              listenerDefinitions.push(definition);\n              set(path, _listenerActionCreators, definition.actionCreator);\n            } else {\n              set(path, _actionCreators, definition.actionCreator);\n            }\n          }\n        } else if (value[thunkSymbol] || value[thunkOnSymbol]) {\n          const definition = { ...value };\n\n          // Determine the category of the thunk\n          const category = definition[thunkSymbol] ? '@thunk' : '@thunkOn';\n\n          // Establish the meta data describing the thunk\n          const type = `${category}.${meta.path.join('.')}`;\n          definition.meta = {\n            actionName: meta.key,\n            parent: meta.parent,\n            path: meta.path,\n            type,\n            startType: `${type}(start)`,\n            successType: `${type}(success)`,\n            failType: `${type}(fail)`,\n          };\n\n          // Create the function that will handle, i.e. be executed, when\n          // the thunk action is created/dispatched\n          definition.thunkHandler = createThunkHandler(\n            definition,\n            references,\n            injections,\n            _actionCreators,\n          );\n\n          // Register the thunk handler\n          set(path, actionThunks, definition.thunkHandler);\n\n          // Create the \"action creator\" function\n          definition.actionCreator = createThunkActionsCreator(\n            definition,\n            references,\n          );\n\n          // Create a bidirectional relationship of the definition/actionCreator\n          definition.actionCreator.definition = definition;\n\n          // Register the action creator within the lookup map\n          _actionCreatorDict[definition.meta.type] = definition.actionCreator;\n\n          // Set the action creator in the \"actions\" object tree for\n          // either the listeners object tree, or the standard actions/thunks\n          // object tree\n          if (definition[thunkOnSymbol]) {\n            listenerDefinitions.push(definition);\n            set(path, _listenerActionCreators, definition.actionCreator);\n          } else {\n            set(path, _actionCreators, definition.actionCreator);\n          }\n        } else if (value[computedSymbol]) {\n          const parent = get(parentPath, _defaultState);\n          const bindComputedProperty = createComputedPropertyBinder(\n            parentPath,\n            key,\n            value,\n            _computedState,\n            references,\n          );\n          bindComputedProperty(parent, _defaultState);\n          _computedProperties.push({ key, parentPath, bindComputedProperty });\n        } else if (value[reducerSymbol]) {\n          _customReducers.push({ key, parentPath, reducer: value.fn });\n        } else if (value[effectOnSymbol]) {\n          const definition = { ...value };\n\n          // Establish the meta data describing the effect\n          const type = `@effectOn.${meta.path.join('.')}`;\n          definition.meta = {\n            type,\n            actionName: meta.key,\n            parent: meta.parent,\n            path: meta.path,\n            startType: `${type}(start)`,\n            successType: `${type}(success)`,\n            failType: `${type}(fail)`,\n          };\n\n          const effectHandler = createEffectHandler(\n            definition,\n            references,\n            injections,\n            _actionCreators,\n          );\n\n          const actionCreator = createEffectActionsCreator(\n            definition,\n            references,\n            effectHandler,\n          );\n\n          definition.actionCreator = actionCreator;\n\n          _effects.push(definition);\n        } else if (isPlainObject(value)) {\n          const existing = get(path, _defaultState);\n          if (existing == null) {\n            set(path, _defaultState, {});\n          }\n          recursiveExtractFromModel(value, path);\n        } else {\n          handleValueAsState();\n        }\n      } else {\n        handleValueAsState();\n      }\n    });\n\n  _persistenceConfig = _persistenceConfig.sort((a, b) => {\n    const aPath = a.path.join('.');\n    const bPath = b.path.join('.');\n    if (aPath < bPath) {\n      return -1;\n    }\n    if (aPath > bPath) {\n      return 1;\n    }\n    return 0;\n  });\n\n  recursiveExtractFromModel(model, []);\n\n  bindListenerDefinitions(\n    listenerDefinitions,\n    _actionCreators,\n    _actionCreatorDict,\n    _listenerActionMap,\n  );\n\n  return {\n    _actionCreatorDict,\n    _actionCreators,\n    _actionReducersDict,\n    _computedProperties,\n    _customReducers,\n    _computedState,\n    _defaultState,\n    _effects,\n    _listenerActionCreators,\n    _listenerActionMap,\n    _persistenceConfig,\n  };\n}\n","export const actionSymbol = '$ep_a';\nexport const actionOnSymbol = '$ep_aO';\nexport const computedSymbol = '$ep_c';\nexport const effectOnSymbol = '$ep_e';\nexport const persistSymbol = '$ep_p';\nexport const reducerSymbol = '$ep_r';\nexport const thunkOnSymbol = '$ep_tO';\nexport const thunkSymbol = '$ep_t';\n","import { actionOnSymbol } from './constants';\n\nexport function createActionCreator(definition, references) {\n  const actionCreator = (payload) => {\n    const action = {\n      type: definition.meta.type,\n      payload,\n    };\n    if (definition[actionOnSymbol] && definition.meta.resolvedTargets) {\n      payload.resolvedTargets = [...definition.meta.resolvedTargets];\n    }\n    return references.dispatch(action);\n  };\n\n  // We bind the types to the creator for easy reference by consumers\n  actionCreator.type = definition.meta.type;\n\n  return actionCreator;\n}\n","/* eslint-disable react/prop-types */\n\nimport React, { createContext, useContext } from 'react';\nimport { useMemoOne } from 'use-memo-one';\nimport {\n  createStoreActionsHook,\n  createStoreDispatchHook,\n  createStoreStateHook,\n  createStoreRehydratedHook,\n} from './hooks';\nimport createStore from './create-store';\n\nexport default function createContextStore(model, config = {}) {\n  // We create a mutable injections reference to allow updating it\n  const { injections: mutableInjections = {} } = config;\n\n  const StoreContext = createContext();\n\n  function Provider({ children, runtimeModel, injections }) {\n    // If the user provided injections we need to ensure our mutable ref\n    // is up to date. We could consider doing a shallow compare here?\n    if (injections != null) {\n      const nextInjections =\n        typeof injections === 'function'\n          ? injections(mutableInjections)\n          : injections;\n      const nextKeys = Object.keys(nextInjections);\n      const removeKeys = Object.keys(mutableInjections).filter(\n        (k) => !nextKeys.includes(k),\n      );\n      removeKeys.forEach((k) => {\n        delete mutableInjections[k];\n      });\n      Object.assign(mutableInjections, nextInjections);\n    }\n\n    const store = useMemoOne(\n      () =>\n        createStore(typeof model === 'function' ? model(runtimeModel) : model, {\n          ...config,\n          originalInjections: mutableInjections,\n        }),\n      [],\n    );\n    return (\n      <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\n    );\n  }\n\n  function useStore() {\n    return useContext(StoreContext);\n  }\n\n  return {\n    Provider,\n    useStore,\n    useStoreState: createStoreStateHook(StoreContext),\n    useStoreActions: createStoreActionsHook(StoreContext),\n    useStoreDispatch: createStoreDispatchHook(StoreContext),\n    useStoreRehydrated: createStoreRehydratedHook(StoreContext),\n  };\n}\n","/**\n * This file has been copied from redux-persist.\n * The intention being to support as much of the redux-persist API as possible.\n */\n\nexport default function createTransform(inbound, outbound, config = {}) {\n  const whitelist = config.whitelist || null;\n  const blacklist = config.blacklist || null;\n\n  function whitelistBlacklistCheck(key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return true;\n    if (blacklist && blacklist.indexOf(key) !== -1) return true;\n    return false;\n  }\n\n  return {\n    in: (data, key, fullState) =>\n      !whitelistBlacklistCheck(key) && inbound\n        ? inbound(data, key, fullState)\n        : data,\n    out: (data, key, fullState) =>\n      !whitelistBlacklistCheck(key) && outbound\n        ? outbound(data, key, fullState)\n        : data,\n  };\n}\n","import React from 'react';\nimport StoreContext from './context';\n\nexport default function StoreProvider({ children, store }) {\n  return (\n    <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\n  );\n}\n","import { useEffect, useRef, useState } from 'react';\nimport { useMemoOne } from 'use-memo-one';\nimport createStore from './create-store';\n\nexport default function useLocalStore(\n  modelCreator,\n  dependencies = [],\n  configCreator,\n) {\n  const storeRef = useRef();\n\n  const configRef = useRef();\n\n  const store = useMemoOne(() => {\n    const previousState =\n      storeRef.current != null ? storeRef.current.getState() : undefined;\n    const config =\n      configCreator != null\n        ? configCreator(previousState, configRef.current)\n        : undefined;\n    const _store = createStore(modelCreator(previousState), config);\n    configRef.current = config;\n    storeRef.current = _store;\n    return _store;\n  }, dependencies);\n\n  const [currentState, setCurrentState] = useState(() => store.getState());\n\n  useEffect(() => {\n    return store.subscribe(() => {\n      const nextState = store.getState();\n      if (currentState !== nextState) {\n        setCurrentState(nextState);\n      }\n    });\n  }, [store]);\n\n  return [currentState, store.getActions(), store];\n}\n"],"names":["StoreContext","createContext","useIsomorphicLayoutEffect","window","useLayoutEffect","useEffect","createStoreStateHook","Context","mapState","equalityFn","store","useContext","mapStateRef","useRef","stateRef","mountedRef","subscriptionMapStateError","forceRender","useReducer","s","current","undefined","getState","err","process","env","NODE_ENV","errorMessage","message","stack","Error","checkMapState","newState","unsubscribe","subscribe","useStoreState","EasyPeasyContext","createStoreActionsHook","mapActions","getActions","useStoreActions","createStoreDispatchHook","dispatch","useStoreDispatch","useStore","createStoreRehydratedHook","useState","rehydrated","setRehydrated","persist","resolveRehydration","then","useStoreRehydrated","createTypedHooks","debug","state","isDraft","memo","fn","cacheSize","memoizerific","actionOn","targetResolver","action","defaultStateResolvers","computed","fnOrStateResolvers","stateResolvers","unstable_effectOn","dependencyResolvers","generic","value","model","config","thunkOn","thunk","reducer","easyPeasyImmer","Immer","useProxies","autoFreeze","deepCloneStateWithoutComputed","source","recursiveClone","next","Object","keys","reduce","acc","key","getOwnPropertyDescriptor","get","forEach","isPlainObject","isPromise","x","path","target","cur","set","length","idx","pSeries","tasks","results","iterable","Promise","resolve","reject","iterator","Symbol","total","element","done","body","recover","result","all","_","task","push","e","error","pReduce","createReducer","disableImmer","_actionReducersDict","_customReducers","_computedProperties","simpleProduce","newify","currentPath","currentState","finalValue","slice","draft","createDraft","finishDraft","parentPath","parent","createSimpleProduce","stateAfterActions","actionReducer","type","payload","runActionReducerAtPath","definition","meta","reducerForActions","red","reducerForCustomReducers","bindComputedProperty","parentState","noopStorage","getItem","setItem","removeItem","getBrowerStorage","storageName","storageCache","localStorage","sessionStorage","createStorageWrapper","storage","transformers","console","warn","outTransformers","reverse","deserialize","data","JSON","parse","out","isAsync","wrapped","stringify","serialize","createPersistenceClearer","persistKey","references","internals","_persistenceConfig","map","rehydrateStateFromPersistIfNeeded","replaceState","root","persistInstance","mergeStrategy","_defaultState","hasDataModelChanged","dataModel","rehydratingModelData","Array","isArray","rehydate","persistedState","originalState","targetState","setAt","currentTargetState","currentPersistedState","applyRehydrationStrategy","getItemResult","logThunkEventListenerError","log","handleEventDispatchErrors","dispatcher","createListenerMiddleware","_listenerActionMap","sourceAction","_actionCreatorDict","actionCreator","createComputedPropertiesMiddleware","_computedState","isInReducer","createEffectsMiddleware","_effects","prevState","nextState","prevLocal","nextLocal","prevDependencies","resolver","nextDependencies","some","dependency","logEffectError","logEffectEventListenerError","createStore","options","modelClone","compose","devTools","enhancers","initialState","injections","middleware","mockActions","name","storeName","version","reducerEnhancer","rootReducer","bindReplaceState","modelDef","ePRS","helpers","modelDefinition","mockedActions","targetPath","join","persistor","nextPersistOperation","persistPromise","isPersisting","timingMethod","requestIdleCallback","requestAnimationFrame","operation","allow","deny","persistTargets","targets","findIndex","resolvePersistTargets","stateToPersist","rawValue","clear","flush","createPersistor","persistMiddleware","createPersistMiddleware","bindStoreInternals","_actionCreators","actionThunks","_listenerActionCreators","listenerDefinitions","sort","a","b","aPath","bPath","recursiveExtractFromModel","handleValueAsState","initialParentRef","category","actionName","resolvedTargets","createActionCreator","startType","successType","failType","thunkHandler","fail","getStoreActions","getStoreState","createThunkHandler","dispatchStart","dispatchFail","dispatchSuccess","failure","_failure","resolved","createThunkActionsCreator","memoisedResultFn","storeState","defineProperty","configurable","enumerable","inputs","createComputedPropertyBinder","effectHandler","dispose","actions","change","disposeResult","effectResult","createEffectHandler","previousDependencies","prev","createEffectActionsCreator","persistDefinition","extractPersistConfig","targetTypes","targetType","listenerReg","bindListenerDefinitions","extractDataFromModel","createStoreInternals","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","reduxCompose","easyPeasyMiddleware","reduxThunk","reduxCreateStore","applyMiddleware","bindActionCreators","actionsKey","rebindStore","removeKey","replaceReducer","assign","addModel","modelForKey","removeModel","addModelRehydration","clearMockedActions","getListeners","getMockedActions","reconfigure","newModel","createContextStore","mutableInjections","Provider","children","runtimeModel","nextInjections","nextKeys","filter","k","includes","useMemoOne","originalInjections","React","createTransform","inbound","outbound","whitelist","blacklist","whitelistBlacklistCheck","indexOf","in","fullState","StoreProvider","useLocalStore","modelCreator","dependencies","configCreator","storeRef","configRef","previousState","_store","setCurrentState"],"mappings":"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"}