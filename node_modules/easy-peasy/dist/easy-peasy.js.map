{"version":3,"file":"easy-peasy.js","sources":["../src/context.js","../src/hooks.js","../src/helpers.js","../src/lib.js","../src/create-reducer.js","../src/persistence.js","../src/thunks.js","../src/listeners.js","../src/computed-properties.js","../src/effects.js","../src/create-store.js","../src/create-store-internals.js","../src/extract-data-from-model.js","../src/constants.js","../src/actions.js","../src/provider.js","../src/create-context-store.js","../src/create-transform.js","../src/use-local-store.js"],"sourcesContent":["import { createContext } from 'react';\n\nconst StoreContext = createContext();\n\nexport default StoreContext;\n","import {\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useReducer,\n  useRef,\n  useState,\n} from 'react';\nimport EasyPeasyContext from './context';\n\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\n// subscription callback always has the selector from the latest render commit\n// available, otherwise a store update may happen between render and the effect,\n// which may cause missed updates; we also must ensure the store subscription\n// is created synchronously, otherwise a store update may occur before the\n// subscription is created and an inconsistent state may be observed\nconst useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect;\n\nexport function createStoreStateHook(Context) {\n  return function useStoreState(mapState, equalityFn) {\n    const store = useContext(Context);\n    const mapStateRef = useRef(mapState);\n    const stateRef = useRef();\n    const mountedRef = useRef(true);\n    const subscriptionMapStateError = useRef();\n\n    const [, forceRender] = useReducer((s) => s + 1, 0);\n\n    if (\n      subscriptionMapStateError.current ||\n      mapStateRef.current !== mapState ||\n      stateRef.current === undefined\n    ) {\n      try {\n        stateRef.current = mapState(store.getState());\n      } catch (err) {\n        if (process.env.NODE_ENV === 'development') {\n          let errorMessage = `An error occurred trying to map state in a useStoreState hook: ${err.message}.`;\n          if (subscriptionMapStateError.current) {\n            errorMessage += `\\nThis error may be related to the following error:\\n${subscriptionMapStateError.current.stack}\\n\\nOriginal stack trace:`;\n          }\n          throw new Error(errorMessage);\n        }\n        throw subscriptionMapStateError.current || err;\n      }\n    }\n\n    useIsomorphicLayoutEffect(() => {\n      mapStateRef.current = mapState;\n      subscriptionMapStateError.current = undefined;\n    });\n\n    useIsomorphicLayoutEffect(() => {\n      const checkMapState = () => {\n        try {\n          const newState = mapStateRef.current(store.getState());\n\n          const isStateEqual =\n            typeof equalityFn === 'function'\n              ? equalityFn(stateRef.current, newState)\n              : stateRef.current === newState;\n\n          if (isStateEqual) {\n            return;\n          }\n\n          stateRef.current = newState;\n        } catch (err) {\n          // see https://github.com/reduxjs/react-redux/issues/1179\n          // There is a possibility mapState will fail due to stale state or\n          // props, therefore we will just track the error and force our\n          // component to update. It should then receive the updated state\n          subscriptionMapStateError.current = err;\n        }\n        if (mountedRef.current) {\n          forceRender({});\n        }\n      };\n      const unsubscribe = store.subscribe(checkMapState);\n      checkMapState();\n      return () => {\n        mountedRef.current = false;\n        unsubscribe();\n      };\n    }, []);\n\n    return stateRef.current;\n  };\n}\n\nexport const useStoreState = createStoreStateHook(EasyPeasyContext);\n\nexport function createStoreActionsHook(Context) {\n  return function useStoreActions(mapActions) {\n    const store = useContext(Context);\n    return mapActions(store.getActions());\n  };\n}\n\nexport const useStoreActions = createStoreActionsHook(EasyPeasyContext);\n\nexport function createStoreDispatchHook(Context) {\n  return function useStoreDispatch() {\n    const store = useContext(Context);\n    return store.dispatch;\n  };\n}\n\nexport const useStoreDispatch = createStoreDispatchHook(EasyPeasyContext);\n\nexport function useStore() {\n  return useContext(EasyPeasyContext);\n}\n\nexport function createStoreRehydratedHook(Context) {\n  return function useStoreRehydrated() {\n    const store = useContext(Context);\n    const [rehydrated, setRehydrated] = useState(false);\n    useEffect(() => {\n      store.persist.resolveRehydration().then(() => setRehydrated(true));\n    }, []);\n    return rehydrated;\n  };\n}\n\nexport const useStoreRehydrated = createStoreRehydratedHook(EasyPeasyContext);\n\nexport function createTypedHooks() {\n  return {\n    useStoreActions,\n    useStoreDispatch,\n    useStoreState,\n    useStoreRehydrated,\n    useStore,\n  };\n}\n","import { isDraft, current } from 'immer';\nimport memoizerific from 'memoizerific';\nimport {\n  actionOnSymbol,\n  actionSymbol,\n  computedSymbol,\n  effectOnSymbol,\n  persistSymbol,\n  reducerSymbol,\n  thunkOnSymbol,\n  thunkSymbol,\n} from './constants';\n\nexport const debug = (state) => {\n  if (isDraft(state)) {\n    return current(state);\n  }\n  return state;\n};\n\nexport const memo = (fn, cacheSize) => memoizerific(cacheSize)(fn);\n\nexport const actionOn = (targetResolver, fn) => {\n  return {\n    [actionOnSymbol]: true,\n    fn,\n    targetResolver,\n  };\n};\n\nexport const action = (fn) => {\n  return {\n    [actionSymbol]: true,\n    fn,\n  };\n};\n\nconst defaultStateResolvers = [(state) => state];\n\nexport const computed = (fnOrStateResolvers, fn) => {\n  if (typeof fn === 'function') {\n    return {\n      [computedSymbol]: true,\n      fn,\n      stateResolvers: fnOrStateResolvers,\n    };\n  }\n  return {\n    [computedSymbol]: true,\n    fn: fnOrStateResolvers,\n    stateResolvers: defaultStateResolvers,\n  };\n};\n\nexport function unstable_effectOn(dependencyResolvers, fn) {\n  return {\n    [effectOnSymbol]: true,\n    dependencyResolvers,\n    fn,\n  };\n}\n\nexport function generic(value) {\n  return value;\n}\n\nexport const persist = (model, config) => {\n  // if we are not running in a browser context this becomes a no-op\n  return typeof window === 'undefined'\n    ? model\n    : {\n        ...model,\n        [persistSymbol]: config,\n      };\n};\n\nexport const thunkOn = (targetResolver, fn) => {\n  return {\n    [thunkOnSymbol]: true,\n    fn,\n    targetResolver,\n  };\n};\n\nexport const thunk = (fn) => {\n  return {\n    [thunkSymbol]: true,\n    fn,\n  };\n};\n\nexport const reducer = (fn) => {\n  return {\n    [reducerSymbol]: true,\n    fn,\n  };\n};\n","import { isPlainObject } from 'is-plain-object';\nimport { Immer, isDraft } from 'immer';\n\n/**\n * We create our own immer instance to avoid potential issues with autoFreeze\n * becoming default enabled everywhere. We want to disable autofreeze as it\n * does not suit the design of Easy Peasy.\n * https://github.com/immerjs/immer/issues/681#issuecomment-705581111\n */\nconst easyPeasyImmer = new Immer({\n  useProxies: true,\n  autoFreeze: false,\n});\n\nexport const deepCloneStateWithoutComputed = (source) => {\n  const recursiveClone = (current) => {\n    const next = Object.keys(current).reduce((acc, key) => {\n      if (Object.getOwnPropertyDescriptor(current, key).get == null) {\n        acc[key] = current[key];\n      }\n      return acc;\n    }, {});\n    Object.keys(next).forEach((key) => {\n      if (isPlainObject(next[key])) {\n        next[key] = recursiveClone(next[key]);\n      }\n    });\n    return next;\n  };\n  return recursiveClone(source);\n};\n\nexport const isPromise = (x) => {\n  return x != null && typeof x === 'object' && typeof x.then === 'function';\n};\n\nexport function get(path, target) {\n  return path.reduce((acc, cur) => {\n    return isPlainObject(acc) ? acc[cur] : undefined;\n  }, target);\n}\n\nexport function newify(currentPath, currentState, finalValue) {\n  if (currentPath.length === 0) {\n    return finalValue;\n  }\n  const newState = { ...currentState };\n  const key = currentPath[0];\n  if (currentPath.length === 1) {\n    newState[key] = finalValue;\n  } else {\n    newState[key] = newify(currentPath.slice(1), newState[key], finalValue);\n  }\n  return newState;\n}\n\nexport const set = (path, target, value) => {\n  if (path.length === 0) {\n    if (typeof value === 'object') {\n      Object.keys(target).forEach((key) => {\n        delete target[key];\n      });\n      Object.keys(value).forEach((key) => {\n        target[key] = value[key];\n      });\n    }\n    return;\n  }\n  path.reduce((acc, cur, idx) => {\n    if (idx + 1 === path.length) {\n      acc[cur] = value;\n    } else {\n      acc[cur] = acc[cur] || {};\n    }\n    return acc[cur];\n  }, target);\n};\n\nexport function createSimpleProduce(disableImmer = false) {\n  return function simpleProduce(path, state, fn) {\n    if (disableImmer) {\n      const current = get(path, state);\n      const next = fn(current);\n      if (current !== next) {\n        return newify(path, state, next);\n      }\n      return state;\n    }\n    if (path.length === 0) {\n      const draft = easyPeasyImmer.createDraft(state);\n      const result = fn(draft);\n      if (result) {\n        return isDraft(result) ? easyPeasyImmer.finishDraft(result) : result;\n      }\n      return easyPeasyImmer.finishDraft(draft);\n    }\n    const parentPath = path.slice(0, path.length - 1);\n    const draft = easyPeasyImmer.createDraft(state);\n    const parent = get(parentPath, state);\n    const current = get(path, draft);\n    const result = fn(current);\n\n    if (result) {\n      parent[path[path.length - 1]] = result;\n    }\n    return easyPeasyImmer.finishDraft(draft);\n  };\n}\n\nconst pReduce = (iterable, reducer, initialValue) =>\n  new Promise((resolve, reject) => {\n    const iterator = iterable[Symbol.iterator]();\n    let index = 0;\n\n    const next = async (total) => {\n      const element = iterator.next();\n\n      if (element.done) {\n        resolve(total);\n        return;\n      }\n\n      try {\n        const value = await Promise.all([total, element.value]);\n        // eslint-disable-next-line no-plusplus\n        next(reducer(value[0], value[1], index++));\n      } catch (error) {\n        reject(error);\n      }\n    };\n\n    next(initialValue);\n  });\n\nexport const pSeries = async (tasks) => {\n  const results = [];\n\n  await pReduce(tasks, async (_, task) => {\n    const value = await task();\n    results.push(value);\n  });\n\n  return results;\n};\n","import { createSimpleProduce, get } from './lib';\n\nexport default function createReducer(\n  disableImmer,\n  _actionReducersDict,\n  _customReducers,\n  _computedProperties,\n) {\n  const simpleProduce = createSimpleProduce(disableImmer);\n\n  const runActionReducerAtPath = (state, action, actionReducer, path) => {\n    return simpleProduce(path, state, (draft) =>\n      actionReducer(draft, action.payload),\n    );\n  };\n\n  const reducerForActions = (state, action) => {\n    const actionReducer = _actionReducersDict[action.type];\n    if (actionReducer) {\n      return runActionReducerAtPath(\n        state,\n        action,\n        actionReducer,\n        actionReducer.definition.meta.parent,\n      );\n    }\n    return state;\n  };\n\n  const reducerForCustomReducers = (state, action) => {\n    return _customReducers.reduce((acc, { parentPath, key, reducer: red }) => {\n      return simpleProduce(parentPath, acc, (draft) => {\n        draft[key] = red(draft[key], action);\n        return draft;\n      });\n    }, state);\n  };\n\n  const rootReducer = (state, action) => {\n    const stateAfterActions = reducerForActions(state, action);\n    const next =\n      _customReducers.length > 0\n        ? reducerForCustomReducers(stateAfterActions, action)\n        : stateAfterActions;\n    if (state !== next) {\n      _computedProperties.forEach(({ parentPath, bindComputedProperty }) => {\n        const parentState = get(parentPath, next);\n        if (parentState != null) bindComputedProperty(parentState, next);\n      });\n    }\n    return next;\n  };\n\n  return rootReducer;\n}\n","import { isPlainObject } from 'is-plain-object';\nimport {\n  deepCloneStateWithoutComputed,\n  get,\n  isPromise,\n  set,\n  pSeries,\n} from './lib';\n\nconst noopStorage = {\n  getItem: () => undefined,\n  setItem: () => undefined,\n  removeItem: () => undefined,\n};\n\nconst getBrowerStorage = (storageName) => {\n  let storageCache;\n  return () => {\n    if (!storageCache) {\n      try {\n        if (\n          typeof window !== 'undefined' &&\n          typeof window[storageName] !== 'undefined'\n        ) {\n          storageCache = window[storageName];\n        }\n      } catch (_) {\n        // swallow the failure\n      }\n      if (!storageCache) {\n        storageCache = noopStorage;\n      }\n    }\n\n    return storageCache;\n  };\n};\n\nconst localStorage = getBrowerStorage('localStorage');\nconst sessionStorage = getBrowerStorage('sessionStorage');\n\nfunction createStorageWrapper(storage, transformers = []) {\n  if (storage == null) {\n    storage = sessionStorage();\n  }\n\n  if (typeof storage === 'string') {\n    if (storage === 'localStorage') {\n      storage = localStorage();\n    } else if (storage === 'sessionStorage') {\n      storage = sessionStorage();\n    } else {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(\n          `Invalid storage provider specified for Easy Peasy persist: ${storage}\\nValid values include \"localStorage\", \"sessionStorage\" or a custom storage engine.`,\n        );\n      }\n      storage = noopStorage;\n    }\n  }\n\n  const outTransformers = [...transformers].reverse();\n\n  const serialize = (data) => {\n    if (transformers.length > 0 && data != null && typeof data === 'object') {\n      Object.keys(data).forEach((key) => {\n        data[key] = transformers.reduce((acc, cur) => {\n          return cur.in(acc, key);\n        }, data[key]);\n      });\n    }\n\n    return storage === localStorage() || storage === sessionStorage()\n      ? JSON.stringify({ data })\n      : data;\n  };\n\n  const deserialize = (data) => {\n    const result =\n      storage === localStorage() || storage === sessionStorage()\n        ? JSON.parse(data).data\n        : data;\n    if (\n      outTransformers.length > 0 &&\n      result != null &&\n      typeof result === 'object'\n    ) {\n      Object.keys(result).forEach((key) => {\n        result[key] = outTransformers.reduce((acc, cur) => {\n          return cur.out(acc, key);\n        }, result[key]);\n      });\n    }\n    return result;\n  };\n\n  const isAsync = isPromise(storage.getItem('_'));\n\n  return {\n    isAsync,\n    getItem: (key) => {\n      if (isAsync) {\n        return storage.getItem(key).then((wrapped) => {\n          return wrapped != null ? deserialize(wrapped) : undefined;\n        });\n      }\n      const wrapped = storage.getItem(key);\n      return wrapped != null ? deserialize(wrapped) : undefined;\n    },\n    setItem: (key, data) => {\n      return storage.setItem(key, serialize(data));\n    },\n    removeItem: (key) => {\n      return storage.removeItem(key);\n    },\n  };\n}\n\nexport function extractPersistConfig(path, persistDefinition = {}) {\n  return {\n    path,\n    config: {\n      allow: persistDefinition.allow || [],\n      deny: persistDefinition.deny || [],\n      mergeStrategy: persistDefinition.mergeStrategy || 'mergeDeep',\n      storage: createStorageWrapper(\n        persistDefinition.storage,\n        persistDefinition.transformers,\n      ),\n    },\n  };\n}\n\nfunction resolvePersistTargets(target, allow, deny) {\n  let targets = Object.keys(target);\n  if (allow.length > 0) {\n    targets = targets.reduce((acc, cur) => {\n      if (allow.findIndex((x) => x === cur) !== -1) {\n        return [...acc, cur];\n      }\n      return acc;\n    }, []);\n  }\n  if (deny.length > 0) {\n    targets = targets.reduce((acc, cur) => {\n      if (deny.findIndex((x) => x === cur) !== -1) {\n        return acc;\n      }\n      return [...acc, cur];\n    }, []);\n  }\n  return targets;\n}\n\nfunction createPersistenceClearer(persistKey, references) {\n  return () => {\n    if (references.internals._persistenceConfig.length === 0) {\n      return Promise.resolve();\n    }\n    return pSeries(\n      references.internals._persistenceConfig.map(({ path, config }) => () =>\n        Promise.resolve(config.storage.removeItem(persistKey(path))),\n      ),\n    );\n  };\n}\n\nexport function createPersistor(persistKey, references) {\n  let persistPromise = Promise.resolve();\n  let isPersisting = false;\n  let nextPersistOperation;\n\n  const timingMethod =\n    typeof window === 'undefined'\n      ? (fn) => fn()\n      : window.requestIdleCallback != null\n      ? window.requestIdleCallback\n      : window.requestAnimationFrame;\n\n  const persist = (nextState) => {\n    if (references.internals._persistenceConfig.length === 0) {\n      return;\n    }\n\n    const operation = () => {\n      isPersisting = true;\n      persistPromise = new Promise((resolve) => {\n        timingMethod(() => {\n          pSeries(\n            references.internals._persistenceConfig.map(\n              ({ path, config }) => () => {\n                const { storage, allow, deny } = config;\n                const persistRootState = deepCloneStateWithoutComputed(\n                  get(path, nextState),\n                );\n                const persistTargets = resolvePersistTargets(\n                  persistRootState,\n                  allow,\n                  deny,\n                );\n                const stateToPersist = {};\n                persistTargets.map((key) => {\n                  const targetPath = [...path, key];\n                  const rawValue = get(targetPath, nextState);\n                  const value = isPlainObject(rawValue)\n                    ? deepCloneStateWithoutComputed(rawValue)\n                    : rawValue;\n                  stateToPersist[key] = value;\n                });\n                return Promise.resolve(\n                  storage.setItem(persistKey(path), stateToPersist),\n                );\n              },\n            ),\n          ).finally(() => {\n            isPersisting = false;\n            if (nextPersistOperation) {\n              const next = nextPersistOperation;\n              nextPersistOperation = null;\n              next();\n            } else {\n              resolve();\n            }\n          });\n        });\n      });\n    };\n\n    if (isPersisting) {\n      nextPersistOperation = operation;\n    } else {\n      operation();\n    }\n  };\n\n  return {\n    persist,\n    clear: createPersistenceClearer(persistKey, references),\n    flush: async () => {\n      if (nextPersistOperation) {\n        nextPersistOperation();\n      }\n      await persistPromise;\n    },\n  };\n}\n\nexport function createPersistMiddleware(persistor, references) {\n  return ({ getState }) => (next) => (action) => {\n    const state = next(action);\n    if (\n      action &&\n      action.type !== '@action.ePRS' &&\n      references.internals._persistenceConfig.length > 0\n    ) {\n      persistor.persist(getState());\n    }\n    return state;\n  };\n}\n\nexport function rehydrateStateFromPersistIfNeeded(\n  persistKey,\n  replaceState,\n  references,\n  root,\n) {\n  if (references.internals._persistenceConfig.length === 0) {\n    return Promise.resolve();\n  }\n\n  return pSeries(\n    references.internals._persistenceConfig.map((persistInstance) => () => {\n      const { path, config } = persistInstance;\n      const { mergeStrategy, storage } = config;\n\n      if (root && (path.length < 1 || path[0] !== root)) {\n        return Promise.resolve();\n      }\n\n      const state = references.internals._defaultState;\n\n      const hasDataModelChanged = (dataModel, rehydratingModelData) =>\n        dataModel != null &&\n        rehydratingModelData != null &&\n        (typeof dataModel !== typeof rehydratingModelData ||\n          (Array.isArray(dataModel) && !Array.isArray(rehydratingModelData)));\n\n      const applyRehydrationStrategy = (originalState, persistedState) => {\n        if (mergeStrategy === 'overwrite') {\n          set(path, originalState, persistedState);\n        } else if (mergeStrategy === 'mergeShallow') {\n          const targetState = get(path, originalState);\n          Object.keys(persistedState).forEach((key) => {\n            if (hasDataModelChanged(targetState[key], persistedState[key])) {\n              // skip as the data model type has changed since the data was persisted\n            } else {\n              targetState[key] = persistedState[key];\n            }\n          });\n        } else if (mergeStrategy === 'mergeDeep') {\n          const targetState = get(path, originalState);\n          const setAt = (currentTargetState, currentPersistedState) => {\n            Object.keys(currentPersistedState).forEach((key) => {\n              if (\n                hasDataModelChanged(\n                  currentTargetState[key],\n                  currentPersistedState[key],\n                )\n              ) {\n                // skip as the data model type has changed since the data was persisted\n              } else if (isPlainObject(currentPersistedState[key])) {\n                currentTargetState[key] = currentTargetState[key] || {};\n                setAt(currentTargetState[key], currentPersistedState[key]);\n              } else {\n                currentTargetState[key] = currentPersistedState[key];\n              }\n            });\n          };\n          setAt(targetState, persistedState);\n        }\n      };\n\n      const rehydate = (persistedState) => {\n        if (persistedState != null) {\n          applyRehydrationStrategy(state, persistedState);\n        }\n        replaceState(state);\n      };\n\n      const getItemResult = storage.getItem(persistKey(path));\n      if (isPromise(getItemResult)) {\n        return getItemResult.then(rehydate);\n      }\n      return Promise.resolve(rehydate(getItemResult));\n    }),\n  );\n}\n","import { thunkOnSymbol } from './constants';\nimport { get, isPromise } from './lib';\n\nexport function createThunkHandler(\n  definition,\n  references,\n  injections,\n  _actionCreators,\n) {\n  return (payload, fail) => {\n    const helpers = {\n      dispatch: references.dispatch,\n      fail,\n      getState: () => get(definition.meta.parent, references.getState()),\n      getStoreActions: () => _actionCreators,\n      getStoreState: references.getState,\n      injections,\n      meta: {\n        key: definition.meta.actionName,\n        parent: definition.meta.parent,\n        path: definition.meta.path,\n      },\n    };\n    if (definition[thunkOnSymbol] && definition.meta.resolvedTargets) {\n      payload.resolvedTargets = [...definition.meta.resolvedTargets];\n    }\n    return definition.fn(\n      get(definition.meta.parent, _actionCreators),\n      payload,\n      helpers,\n    );\n  };\n}\n\nconst logThunkEventListenerError = (type, err) => {\n  // eslint-disable-next-line no-console\n  console.log(`An error occurred in a listener for ${type}`);\n  // eslint-disable-next-line no-console\n  console.log(err);\n};\n\nconst handleEventDispatchErrors = (type, dispatcher) => (...args) => {\n  try {\n    const result = dispatcher(...args);\n    if (isPromise(result)) {\n      result.catch((err) => {\n        logThunkEventListenerError(type, err);\n      });\n    }\n  } catch (err) {\n    logThunkEventListenerError(type, err);\n  }\n};\n\nexport function createThunkActionsCreator(definition, references) {\n  const actionCreator = (payload) => {\n    const dispatchStart = handleEventDispatchErrors(\n      definition.meta.startType,\n      () =>\n        references.dispatch({\n          type: definition.meta.startType,\n          payload,\n        }),\n    );\n\n    const dispatchFail = handleEventDispatchErrors(\n      definition.meta.failType,\n      (err) =>\n        references.dispatch({\n          type: definition.meta.failType,\n          payload,\n          error: err,\n        }),\n    );\n\n    const dispatchSuccess = handleEventDispatchErrors(\n      definition.meta.successType,\n      (result) =>\n        references.dispatch({\n          type: definition.meta.successType,\n          payload,\n          result,\n        }),\n    );\n\n    dispatchStart();\n\n    let failure = null;\n\n    const fail = (_failure) => {\n      failure = _failure;\n    };\n\n    const result = references.dispatch(() =>\n      definition.thunkHandler(payload, fail),\n    );\n\n    if (isPromise(result)) {\n      return result.then((resolved) => {\n        if (failure) {\n          dispatchFail(failure);\n        } else {\n          dispatchSuccess(resolved);\n        }\n        return resolved;\n      });\n    }\n\n    if (failure) {\n      dispatchFail(failure);\n    } else {\n      dispatchSuccess(result);\n    }\n\n    return result;\n  };\n\n  actionCreator.type = definition.meta.type;\n  actionCreator.successType = definition.meta.successType;\n  actionCreator.failType = definition.meta.failType;\n  actionCreator.startType = definition.meta.startType;\n\n  return actionCreator;\n}\n","import { get } from './lib';\n\nexport function createListenerMiddleware(references) {\n  return () => (next) => (action) => {\n    const result = next(action);\n    if (\n      action &&\n      references.internals._listenerActionMap[action.type] &&\n      references.internals._listenerActionMap[action.type].length > 0\n    ) {\n      const sourceAction = references.internals._actionCreatorDict[action.type];\n      references.internals._listenerActionMap[action.type].forEach(\n        (actionCreator) => {\n          actionCreator({\n            type: sourceAction\n              ? sourceAction.definition.meta.type\n              : action.type,\n            payload: action.payload,\n            error: action.error,\n            result: action.result,\n          });\n        },\n      );\n    }\n    return result;\n  };\n}\n\nexport function bindListenerDefinitions(\n  listenerDefinitions,\n  _actionCreators,\n  _actionCreatorDict,\n  _listenerActionMap,\n) {\n  listenerDefinitions.forEach((definition) => {\n    const targets = definition.targetResolver(\n      get(definition.meta.parent, _actionCreators),\n      _actionCreators,\n    );\n\n    const targetTypes = (Array.isArray(targets) ? targets : [targets]).reduce(\n      (acc, target) => {\n        if (\n          typeof target === 'function' &&\n          target.definition.meta.type &&\n          _actionCreatorDict[target.definition.meta.type]\n        ) {\n          if (target.definition.meta.successType) {\n            acc.push(target.definition.meta.successType);\n            // acc.push(target.definition.meta.failType);\n          } else {\n            acc.push(target.definition.meta.type);\n          }\n        } else if (typeof target === 'string') {\n          acc.push(target);\n        }\n        return acc;\n      },\n      [],\n    );\n\n    definition.meta.resolvedTargets = targetTypes;\n\n    targetTypes.forEach((targetType) => {\n      const listenerReg = _listenerActionMap[targetType] || [];\n      listenerReg.push(_actionCreatorDict[definition.meta.type]);\n      _listenerActionMap[targetType] = listenerReg;\n    });\n  });\n}\n","import memoizerific from 'memoizerific';\nimport { get } from './lib';\n\nexport function createComputedPropertyBinder(\n  parentPath,\n  key,\n  definition,\n  _computedState,\n  references,\n) {\n  const memoisedResultFn = memoizerific(1)(definition.fn);\n  return function createComputedProperty(parentState, storeState) {\n    Object.defineProperty(parentState, key, {\n      configurable: true,\n      enumerable: true,\n      get: () => {\n        const state = get(parentPath, storeState);\n        const inputs = definition.stateResolvers.map((resolver) =>\n          resolver(state, storeState),\n        );\n        return memoisedResultFn(...inputs);\n      },\n    });\n  };\n}\n\nexport function createComputedPropertiesMiddleware(references) {\n  return (store) => (next) => (action) => {\n    references.internals._computedState.currentState = store.getState();\n    references.internals._computedState.isInReducer = true;\n    return next(action);\n  };\n}\n","import { get, isPromise } from './lib';\n\nexport function createEffectsMiddleware(references) {\n  return (store) => (next) => (action) => {\n    if (references.internals._effects.length === 0) {\n      return next(action);\n    }\n    const prevState = store.getState();\n    const result = next(action);\n    const nextState = store.getState();\n    references.internals._effects.forEach((definition) => {\n      const prevLocal = get(definition.meta.parent, prevState);\n      const nextLocal = get(definition.meta.parent, nextState);\n      if (prevLocal !== nextLocal) {\n        const prevDependencies = definition.dependencyResolvers.map(\n          (resolver) => resolver(prevLocal),\n        );\n        const nextDependencies = definition.dependencyResolvers.map(\n          (resolver) => resolver(nextLocal),\n        );\n        const hasChanged = prevDependencies.some((dependency, idx) => {\n          return dependency !== nextDependencies[idx];\n        });\n        if (hasChanged) {\n          definition.actionCreator(prevDependencies, nextDependencies, action);\n        }\n      }\n    });\n    return result;\n  };\n}\n\nconst logEffectError = (err) => {\n  // As users can't get a handle on effects we need to report the error\n  // eslint-disable-next-line no-console\n  console.log(err);\n};\n\nexport function createEffectHandler(\n  definition,\n  references,\n  injections,\n  _actionCreators,\n) {\n  const actions = get(definition.meta.parent, _actionCreators);\n\n  let dispose;\n\n  return (change) => {\n    const helpers = {\n      dispatch: references.dispatch,\n      getState: () => get(definition.meta.parent, references.getState()),\n      getStoreActions: () => _actionCreators,\n      getStoreState: references.getState,\n      injections,\n      meta: {\n        key: definition.meta.actionName,\n        parent: definition.meta.parent,\n        path: definition.meta.path,\n      },\n    };\n\n    if (dispose !== undefined) {\n      const disposeResult = dispose();\n      dispose = undefined;\n      if (isPromise(disposeResult)) {\n        disposeResult.catch(logEffectError);\n      }\n    }\n\n    const effectResult = definition.fn(actions, change, helpers);\n\n    if (isPromise(effectResult)) {\n      return effectResult.then((resolved) => {\n        if (typeof resolved === 'function') {\n          if (process.env.NODE_ENV !== 'production') {\n            // Dispose functions are not allowed to be resolved asynchronously.\n            // Doing so would provide inconsistent behaviour around their execution.\n            // eslint-disable-next-line no-console\n            console.warn(\n              '[easy-peasy] You have an effect which is asynchronously resolving a dispose function. This is considered an anti-pattern. Please read the API documentation for more information.',\n            );\n          }\n        }\n      });\n    }\n\n    if (typeof effectResult === 'function') {\n      dispose = effectResult;\n    }\n\n    return undefined;\n  };\n}\n\nconst logEffectEventListenerError = (type, err) => {\n  // eslint-disable-next-line no-console\n  console.log(`An error occurred in a listener for ${type}`);\n  // eslint-disable-next-line no-console\n  console.log(err);\n};\n\nconst handleEventDispatchErrors = (type, dispatcher) => (...args) => {\n  try {\n    const result = dispatcher(...args);\n    if (isPromise(result)) {\n      result.catch((err) => {\n        logEffectEventListenerError(type, err);\n      });\n    }\n  } catch (err) {\n    logEffectEventListenerError(type, err);\n  }\n};\n\nexport function createEffectActionsCreator(\n  definition,\n  references,\n  effectHandler,\n) {\n  const actionCreator = (previousDependencies, nextDependencies, action) => {\n    const change = {\n      prev: previousDependencies,\n      current: nextDependencies,\n      action,\n    };\n\n    const dispatchStart = handleEventDispatchErrors(\n      definition.meta.startType,\n      () =>\n        references.dispatch({\n          type: definition.meta.startType,\n          change,\n        }),\n    );\n\n    const dispatchSuccess = handleEventDispatchErrors(\n      definition.meta.successType,\n      () =>\n        references.dispatch({\n          type: definition.meta.successType,\n          change,\n        }),\n    );\n\n    dispatchStart();\n\n    try {\n      const result = references.dispatch(() => effectHandler(change));\n\n      if (isPromise(result)) {\n        return result.then((resolved) => {\n          dispatchSuccess(resolved);\n          return resolved;\n        }, logEffectError);\n      }\n\n      dispatchSuccess(result);\n\n      return result;\n    } catch (err) {\n      logEffectError(err);\n    }\n  };\n\n  actionCreator.type = definition.meta.type;\n  actionCreator.startType = definition.meta.startType;\n  actionCreator.successType = definition.meta.successType;\n  actionCreator.failType = definition.meta.failType;\n\n  return actionCreator;\n}\n","import {\n  applyMiddleware,\n  compose as reduxCompose,\n  createStore as reduxCreateStore,\n} from 'redux';\nimport reduxThunk from 'redux-thunk';\nimport * as helpers from './helpers';\nimport createStoreInternals from './create-store-internals';\nimport {\n  createPersistor,\n  createPersistMiddleware,\n  rehydrateStateFromPersistIfNeeded,\n} from './persistence';\nimport { createComputedPropertiesMiddleware } from './computed-properties';\nimport { createListenerMiddleware } from './listeners';\nimport { deepCloneStateWithoutComputed } from './lib';\nimport { createEffectsMiddleware } from './effects';\n\nexport default function createStore(model, options = {}) {\n  const modelClone = deepCloneStateWithoutComputed(model);\n  const {\n    compose,\n    devTools = process.env.NODE_ENV !== 'production',\n    disableImmer = false,\n    enhancers = [],\n    initialState = {},\n    injections = {},\n    middleware = [],\n    mockActions = false,\n    name: storeName = `EasyPeasyStore`,\n    version = 0,\n    reducerEnhancer = (rootReducer) => rootReducer,\n  } = options;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof injections !== 'object') {\n      throw new Error('[easy-peasy] Store injections must be an object');\n    }\n  }\n\n  const bindReplaceState = (modelDef) => {\n    return {\n      ...modelDef,\n      ePRS: helpers.action((_, payload) => payload),\n    };\n  };\n\n  const references = {};\n\n  let modelDefinition = bindReplaceState(modelClone);\n  let mockedActions = [];\n\n  const persistKey = (targetPath) =>\n    `[${storeName}][${version}]${\n      targetPath.length > 0 ? `[${targetPath.join('.')}]` : ''\n    }`;\n  const persistor = createPersistor(persistKey, references);\n  const persistMiddleware = createPersistMiddleware(persistor, references);\n\n  const replaceState = (nextState) =>\n    references.internals._actionCreatorDict['@action.ePRS'](nextState);\n\n  const bindStoreInternals = (state = {}) => {\n    references.internals = createStoreInternals({\n      disableImmer,\n      initialState: state,\n      injections,\n      model: modelDefinition,\n      reducerEnhancer,\n      references,\n    });\n  };\n\n  const mockActionsMiddleware = () => () => (action) => {\n    if (action != null) {\n      mockedActions.push(action);\n    }\n    return undefined;\n  };\n\n  const composeEnhancers =\n    compose ||\n    (devTools &&\n    typeof window !== 'undefined' &&\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\n      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({\n          name: storeName,\n        })\n      : reduxCompose);\n\n  bindStoreInternals(initialState);\n\n  const easyPeasyMiddleware = [\n    createComputedPropertiesMiddleware(references),\n    ...middleware,\n    reduxThunk,\n    createListenerMiddleware(references),\n    createEffectsMiddleware(references),\n    persistMiddleware,\n  ];\n\n  if (mockActions) {\n    easyPeasyMiddleware.push(mockActionsMiddleware);\n  }\n\n  const store = reduxCreateStore(\n    references.internals.reducer,\n    references.internals._defaultState,\n    composeEnhancers(applyMiddleware(...easyPeasyMiddleware), ...enhancers),\n  );\n\n  store.subscribe(() => {\n    references.internals._computedState.isInReducer = false;\n  });\n\n  references.dispatch = store.dispatch;\n  references.getState = store.getState;\n\n  const bindActionCreators = () => {\n    Object.keys(store.dispatch).forEach((actionsKey) => {\n      delete store.dispatch[actionsKey];\n    });\n    Object.keys(references.internals._actionCreators).forEach((key) => {\n      store.dispatch[key] = references.internals._actionCreators[key];\n    });\n  };\n\n  bindActionCreators();\n\n  const rebindStore = (removeKey) => {\n    const currentState = store.getState();\n    if (removeKey) {\n      delete currentState[removeKey];\n    }\n    bindStoreInternals(currentState);\n    store.replaceReducer(references.internals.reducer);\n    replaceState(references.internals._defaultState);\n    bindActionCreators();\n  };\n\n  const resolveRehydration = rehydrateStateFromPersistIfNeeded(\n    persistKey,\n    replaceState,\n    references,\n  );\n\n  return Object.assign(store, {\n    addModel: (key, modelForKey) => {\n      if (modelDefinition[key] && process.env.NODE_ENV !== 'production') {\n        // eslint-disable-next-line no-console\n        console.warn(\n          `easy-peasy: The store model already contains a model definition for \"${key}\"`,\n        );\n        store.removeModel(key);\n      }\n      modelDefinition[key] = modelForKey;\n      rebindStore();\n      // There may have been persisted state for a dynamic model. We should try\n      // and rehydrate the specifc node\n      const addModelRehydration = rehydrateStateFromPersistIfNeeded(\n        persistKey,\n        replaceState,\n        references,\n        key,\n      );\n      return {\n        resolveRehydration: () => addModelRehydration,\n      };\n    },\n    clearMockedActions: () => {\n      mockedActions = [];\n    },\n    getActions: () => references.internals._actionCreators,\n    getListeners: () => references.internals._listenerActionCreators,\n    getMockedActions: () => [...mockedActions],\n    persist: {\n      clear: persistor.clear,\n      flush: persistor.flush,\n      resolveRehydration: () => resolveRehydration,\n    },\n    reconfigure: (newModel) => {\n      modelDefinition = bindReplaceState(newModel);\n      rebindStore();\n    },\n    removeModel: (key) => {\n      if (!modelDefinition[key]) {\n        if (process.env.NODE_ENV !== 'production') {\n          // eslint-disable-next-line no-console\n          console.warn(\n            `easy-peasy: The store model does not contain a model definition for \"${key}\"`,\n          );\n        }\n        return;\n      }\n      delete modelDefinition[key];\n      rebindStore(key);\n    },\n  });\n}\n","import createReducer from './create-reducer';\nimport extractDataFromModel from './extract-data-from-model';\n\nexport default function createStoreInternals({\n  disableImmer,\n  initialState,\n  injections,\n  model,\n  reducerEnhancer,\n  references,\n}) {\n  const {\n    _actionCreatorDict,\n    _actionCreators,\n    _actionReducersDict,\n    _computedState,\n    _computedProperties,\n    _customReducers,\n    _defaultState,\n    _effects,\n    _listenerActionCreators,\n    _listenerActionMap,\n    _persistenceConfig,\n  } = extractDataFromModel(model, initialState, injections, references);\n\n  const rootReducer = createReducer(\n    disableImmer,\n    _actionReducersDict,\n    _customReducers,\n    _computedProperties,\n  );\n\n  return {\n    _actionCreatorDict,\n    _actionCreators,\n    _computedProperties,\n    _computedState,\n    _defaultState,\n    _effects,\n    _listenerActionCreators,\n    _listenerActionMap,\n    _persistenceConfig,\n    reducer: reducerEnhancer(rootReducer),\n  };\n}\n","import { isPlainObject } from 'is-plain-object';\nimport {\n  actionOnSymbol,\n  actionSymbol,\n  computedSymbol,\n  effectOnSymbol,\n  persistSymbol,\n  reducerSymbol,\n  thunkOnSymbol,\n  thunkSymbol,\n} from './constants';\nimport { get, set } from './lib';\nimport { extractPersistConfig } from './persistence';\nimport { createActionCreator } from './actions';\nimport { createThunkHandler, createThunkActionsCreator } from './thunks';\nimport { bindListenerDefinitions } from './listeners';\nimport { createComputedPropertyBinder } from './computed-properties';\nimport { createEffectHandler, createEffectActionsCreator } from './effects';\n\nexport default function extractDataFromModel(\n  model,\n  initialState,\n  injections,\n  references,\n) {\n  const _defaultState = initialState;\n  const _actionCreatorDict = {};\n  const _actionCreators = {};\n  const _actionReducersDict = {};\n  const actionThunks = {};\n  const _computedProperties = [];\n  const _customReducers = [];\n  const _effects = [];\n  const _listenerActionCreators = {};\n  const _listenerActionMap = {};\n  const listenerDefinitions = [];\n  let _persistenceConfig = [];\n  const _computedState = {\n    isInReducer: false,\n    currentState: _defaultState,\n  };\n\n  const recursiveExtractFromModel = (current, parentPath) =>\n    Object.keys(current).forEach((key) => {\n      const value = current[key];\n      const path = [...parentPath, key];\n      const meta = {\n        parent: parentPath,\n        path,\n        key,\n      };\n      const handleValueAsState = () => {\n        const initialParentRef = get(parentPath, initialState);\n        if (initialParentRef && key in initialParentRef) {\n          set(path, _defaultState, initialParentRef[key]);\n        } else {\n          set(path, _defaultState, value);\n        }\n      };\n\n      if (key === persistSymbol) {\n        _persistenceConfig.push(extractPersistConfig(parentPath, value));\n        return;\n      }\n\n      if (value != null && typeof value === 'object') {\n        if (value[actionSymbol] || value[actionOnSymbol]) {\n          const definition = { ...value };\n\n          // Determine the category of the action\n          const category = definition[actionSymbol] ? '@action' : '@actionOn';\n\n          // Establish the meta data describing the action\n          definition.meta = {\n            actionName: meta.key,\n            category,\n            type: `${category}.${meta.path.join('.')}`,\n            parent: meta.parent,\n            path: meta.path,\n          };\n\n          // Create the \"action creator\" function\n          definition.actionCreator = createActionCreator(\n            definition,\n            references,\n          );\n\n          // Create a bidirectional relationship of the definition/actionCreator\n          definition.actionCreator.definition = definition;\n\n          // Create a bidirectional relationship of the definition/reducer\n          definition.fn.definition = definition;\n\n          // Add the action creator to lookup map\n          _actionCreatorDict[definition.meta.type] = definition.actionCreator;\n\n          // Add the reducer to lookup map\n          _actionReducersDict[definition.meta.type] = definition.fn;\n\n          // We don't want to expose the internal action to consumers\n          if (meta.key !== 'ePRS') {\n            // Set the action creator in the \"actions\" object tree for\n            // either the listeners object tree, or the standard actions/thunks\n            // object tree\n            if (definition[actionOnSymbol]) {\n              listenerDefinitions.push(definition);\n              set(path, _listenerActionCreators, definition.actionCreator);\n            } else {\n              set(path, _actionCreators, definition.actionCreator);\n            }\n          }\n        } else if (value[thunkSymbol] || value[thunkOnSymbol]) {\n          const definition = { ...value };\n\n          // Determine the category of the thunk\n          const category = definition[thunkSymbol] ? '@thunk' : '@thunkOn';\n\n          // Establish the meta data describing the thunk\n          const type = `${category}.${meta.path.join('.')}`;\n          definition.meta = {\n            actionName: meta.key,\n            parent: meta.parent,\n            path: meta.path,\n            type,\n            startType: `${type}(start)`,\n            successType: `${type}(success)`,\n            failType: `${type}(fail)`,\n          };\n\n          // Create the function that will handle, i.e. be executed, when\n          // the thunk action is created/dispatched\n          definition.thunkHandler = createThunkHandler(\n            definition,\n            references,\n            injections,\n            _actionCreators,\n          );\n\n          // Register the thunk handler\n          set(path, actionThunks, definition.thunkHandler);\n\n          // Create the \"action creator\" function\n          definition.actionCreator = createThunkActionsCreator(\n            definition,\n            references,\n          );\n\n          // Create a bidirectional relationship of the definition/actionCreator\n          definition.actionCreator.definition = definition;\n\n          // Register the action creator within the lookup map\n          _actionCreatorDict[definition.meta.type] = definition.actionCreator;\n\n          // Set the action creator in the \"actions\" object tree for\n          // either the listeners object tree, or the standard actions/thunks\n          // object tree\n          if (definition[thunkOnSymbol]) {\n            listenerDefinitions.push(definition);\n            set(path, _listenerActionCreators, definition.actionCreator);\n          } else {\n            set(path, _actionCreators, definition.actionCreator);\n          }\n        } else if (value[computedSymbol]) {\n          const parent = get(parentPath, _defaultState);\n          const bindComputedProperty = createComputedPropertyBinder(\n            parentPath,\n            key,\n            value,\n            _computedState,\n            references,\n          );\n          bindComputedProperty(parent, _defaultState);\n          _computedProperties.push({ key, parentPath, bindComputedProperty });\n        } else if (value[reducerSymbol]) {\n          _customReducers.push({ key, parentPath, reducer: value.fn });\n        } else if (value[effectOnSymbol]) {\n          const definition = { ...value };\n\n          // Establish the meta data describing the effect\n          const type = `@effectOn.${meta.path.join('.')}`;\n          definition.meta = {\n            type,\n            actionName: meta.key,\n            parent: meta.parent,\n            path: meta.path,\n            startType: `${type}(start)`,\n            successType: `${type}(success)`,\n            failType: `${type}(fail)`,\n          };\n\n          const effectHandler = createEffectHandler(\n            definition,\n            references,\n            injections,\n            _actionCreators,\n          );\n\n          const actionCreator = createEffectActionsCreator(\n            definition,\n            references,\n            effectHandler,\n          );\n\n          definition.actionCreator = actionCreator;\n\n          _effects.push(definition);\n        } else if (isPlainObject(value)) {\n          const existing = get(path, _defaultState);\n          if (existing == null) {\n            set(path, _defaultState, {});\n          }\n          recursiveExtractFromModel(value, path);\n        } else {\n          handleValueAsState();\n        }\n      } else {\n        handleValueAsState();\n      }\n    });\n\n  _persistenceConfig = _persistenceConfig.sort((a, b) => {\n    const aPath = a.path.join('.');\n    const bPath = b.path.join('.');\n    if (aPath < bPath) {\n      return -1;\n    }\n    if (aPath > bPath) {\n      return 1;\n    }\n    return 0;\n  });\n\n  recursiveExtractFromModel(model, []);\n\n  bindListenerDefinitions(\n    listenerDefinitions,\n    _actionCreators,\n    _actionCreatorDict,\n    _listenerActionMap,\n  );\n\n  return {\n    _actionCreatorDict,\n    _actionCreators,\n    _actionReducersDict,\n    _computedProperties,\n    _customReducers,\n    _computedState,\n    _defaultState,\n    _effects,\n    _listenerActionCreators,\n    _listenerActionMap,\n    _persistenceConfig,\n  };\n}\n","export const actionSymbol = '$ep_a';\nexport const actionOnSymbol = '$ep_aO';\nexport const computedSymbol = '$ep_c';\nexport const effectOnSymbol = '$ep_e';\nexport const persistSymbol = '$ep_p';\nexport const reducerSymbol = '$ep_r';\nexport const thunkOnSymbol = '$ep_tO';\nexport const thunkSymbol = '$ep_t';\n","import { actionOnSymbol } from './constants';\n\nexport function createActionCreator(definition, references) {\n  const actionCreator = (payload) => {\n    const action = {\n      type: definition.meta.type,\n      payload,\n    };\n    if (definition[actionOnSymbol] && definition.meta.resolvedTargets) {\n      payload.resolvedTargets = [...definition.meta.resolvedTargets];\n    }\n    return references.dispatch(action);\n  };\n\n  // We bind the types to the creator for easy reference by consumers\n  actionCreator.type = definition.meta.type;\n\n  return actionCreator;\n}\n","import React from 'react';\nimport StoreContext from './context';\n\nexport default function StoreProvider({ children, store }) {\n  return (\n    <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\n  );\n}\n","/* eslint-disable react/prop-types */\n\nimport React, { createContext, useContext } from 'react';\nimport { useMemoOne } from 'use-memo-one';\nimport {\n  createStoreActionsHook,\n  createStoreDispatchHook,\n  createStoreStateHook,\n  createStoreRehydratedHook,\n} from './hooks';\nimport createStore from './create-store';\n\nexport default function createContextStore(model, config = {}) {\n  // We create a mutable injections reference to allow updating it\n  const { injections: mutableInjections = {} } = config;\n\n  const StoreContext = createContext();\n\n  function Provider({ children, runtimeModel, injections }) {\n    // If the user provided injections we need to ensure our mutable ref\n    // is up to date. We could consider doing a shallow compare here?\n    if (injections != null) {\n      const nextInjections =\n        typeof injections === 'function'\n          ? injections(mutableInjections)\n          : injections;\n      const nextKeys = Object.keys(nextInjections);\n      const removeKeys = Object.keys(mutableInjections).filter(\n        (k) => !nextKeys.includes(k),\n      );\n      removeKeys.forEach((k) => {\n        delete mutableInjections[k];\n      });\n      Object.assign(mutableInjections, nextInjections);\n    }\n\n    const store = useMemoOne(\n      () =>\n        createStore(typeof model === 'function' ? model(runtimeModel) : model, {\n          ...config,\n          originalInjections: mutableInjections,\n        }),\n      [],\n    );\n    return (\n      <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\n    );\n  }\n\n  function useStore() {\n    return useContext(StoreContext);\n  }\n\n  return {\n    Provider,\n    useStore,\n    useStoreState: createStoreStateHook(StoreContext),\n    useStoreActions: createStoreActionsHook(StoreContext),\n    useStoreDispatch: createStoreDispatchHook(StoreContext),\n    useStoreRehydrated: createStoreRehydratedHook(StoreContext),\n  };\n}\n","/**\n * This file has been copied from redux-persist.\n * The intention being to support as much of the redux-persist API as possible.\n */\n\nexport default function createTransform(inbound, outbound, config = {}) {\n  const whitelist = config.whitelist || null;\n  const blacklist = config.blacklist || null;\n\n  function whitelistBlacklistCheck(key) {\n    if (whitelist && whitelist.indexOf(key) === -1) return true;\n    if (blacklist && blacklist.indexOf(key) !== -1) return true;\n    return false;\n  }\n\n  return {\n    in: (data, key, fullState) =>\n      !whitelistBlacklistCheck(key) && inbound\n        ? inbound(data, key, fullState)\n        : data,\n    out: (data, key, fullState) =>\n      !whitelistBlacklistCheck(key) && outbound\n        ? outbound(data, key, fullState)\n        : data,\n  };\n}\n","import { useEffect, useRef, useState } from 'react';\nimport { useMemoOne } from 'use-memo-one';\nimport createStore from './create-store';\n\nexport default function useLocalStore(\n  modelCreator,\n  dependencies = [],\n  configCreator,\n) {\n  const storeRef = useRef();\n\n  const configRef = useRef();\n\n  const store = useMemoOne(() => {\n    const previousState =\n      storeRef.current != null ? storeRef.current.getState() : undefined;\n    const config =\n      configCreator != null\n        ? configCreator(previousState, configRef.current)\n        : undefined;\n    const _store = createStore(modelCreator(previousState), config);\n    configRef.current = config;\n    storeRef.current = _store;\n    return _store;\n  }, dependencies);\n\n  const [currentState, setCurrentState] = useState(() => store.getState());\n\n  useEffect(() => {\n    return store.subscribe(() => {\n      const nextState = store.getState();\n      if (currentState !== nextState) {\n        setCurrentState(nextState);\n      }\n    });\n  }, [store]);\n\n  return [currentState, store.getActions(), store];\n}\n"],"names":["StoreContext","createContext","useIsomorphicLayoutEffect","window","useLayoutEffect","useEffect","createStoreStateHook","Context","mapState","equalityFn","store","useContext","mapStateRef","useRef","stateRef","mountedRef","subscriptionMapStateError","forceRender","useReducer","s","current","undefined","getState","err","process","env","NODE_ENV","errorMessage","message","stack","Error","checkMapState","newState","unsubscribe","subscribe","useStoreState","EasyPeasyContext","createStoreActionsHook","mapActions","getActions","useStoreActions","createStoreDispatchHook","dispatch","useStoreDispatch","useStore","createStoreRehydratedHook","useState","rehydrated","setRehydrated","persist","resolveRehydration","then","useStoreRehydrated","action","fn","defaultStateResolvers","state","easyPeasyImmer","Immer","useProxies","autoFreeze","deepCloneStateWithoutComputed","source","recursiveClone","next","Object","keys","reduce","acc","key","getOwnPropertyDescriptor","get","forEach","isPlainObject","isPromise","x","path","target","cur","set","value","length","idx","pSeries","tasks","results","iterable","Promise","resolve","reject","iterator","Symbol","total","element","done","body","recover","result","all","_","task","push","reducer","e","error","pReduce","createReducer","disableImmer","_actionReducersDict","_customReducers","_computedProperties","simpleProduce","newify","currentPath","currentState","finalValue","slice","draft","createDraft","isDraft","finishDraft","parentPath","parent","createSimpleProduce","stateAfterActions","actionReducer","type","payload","runActionReducerAtPath","definition","meta","reducerForActions","red","reducerForCustomReducers","bindComputedProperty","parentState","noopStorage","getItem","setItem","removeItem","getBrowerStorage","storageName","storageCache","localStorage","sessionStorage","createStorageWrapper","storage","transformers","console","warn","outTransformers","reverse","deserialize","data","JSON","parse","out","isAsync","wrapped","stringify","serialize","createPersistenceClearer","persistKey","references","internals","_persistenceConfig","map","config","rehydrateStateFromPersistIfNeeded","replaceState","root","persistInstance","mergeStrategy","_defaultState","hasDataModelChanged","dataModel","rehydratingModelData","Array","isArray","rehydate","persistedState","originalState","targetState","setAt","currentTargetState","currentPersistedState","applyRehydrationStrategy","getItemResult","logThunkEventListenerError","log","handleEventDispatchErrors","dispatcher","createListenerMiddleware","_listenerActionMap","sourceAction","_actionCreatorDict","actionCreator","createComputedPropertiesMiddleware","_computedState","isInReducer","createEffectsMiddleware","_effects","prevState","nextState","prevLocal","nextLocal","prevDependencies","dependencyResolvers","resolver","nextDependencies","some","dependency","logEffectError","logEffectEventListenerError","createStore","model","options","modelClone","compose","devTools","enhancers","initialState","injections","middleware","mockActions","name","storeName","version","reducerEnhancer","rootReducer","bindReplaceState","modelDef","ePRS","helpers","modelDefinition","mockedActions","targetPath","join","persistor","nextPersistOperation","persistPromise","isPersisting","timingMethod","requestIdleCallback","requestAnimationFrame","operation","allow","deny","persistTargets","targets","findIndex","resolvePersistTargets","stateToPersist","rawValue","clear","flush","createPersistor","persistMiddleware","createPersistMiddleware","bindStoreInternals","_actionCreators","actionThunks","_listenerActionCreators","listenerDefinitions","sort","a","b","aPath","bPath","recursiveExtractFromModel","handleValueAsState","initialParentRef","category","actionName","resolvedTargets","createActionCreator","startType","successType","failType","thunkHandler","fail","getStoreActions","getStoreState","createThunkHandler","dispatchStart","dispatchFail","dispatchSuccess","failure","_failure","resolved","createThunkActionsCreator","memoisedResultFn","memoizerific","storeState","defineProperty","configurable","enumerable","inputs","stateResolvers","createComputedPropertyBinder","effectHandler","dispose","actions","change","disposeResult","effectResult","createEffectHandler","previousDependencies","prev","createEffectActionsCreator","persistDefinition","extractPersistConfig","targetResolver","targetTypes","targetType","listenerReg","bindListenerDefinitions","extractDataFromModel","createStoreInternals","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","reduxCompose","easyPeasyMiddleware","reduxThunk","reduxCreateStore","applyMiddleware","bindActionCreators","actionsKey","rebindStore","removeKey","replaceReducer","assign","addModel","modelForKey","removeModel","addModelRehydration","clearMockedActions","getListeners","getMockedActions","reconfigure","newModel","React","Provider","children","fnOrStateResolvers","mutableInjections","runtimeModel","nextInjections","nextKeys","filter","k","includes","useMemoOne","originalInjections","inbound","outbound","whitelist","blacklist","whitelistBlacklistCheck","indexOf","in","fullState","cacheSize","modelCreator","dependencies","configCreator","storeRef","configRef","previousState","_store","setCurrentState"],"mappings":"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"}